
%option c++
%option warn
%option noyywrap
%option nounistd
%option yylineno

%{

/* +-------------------------------------------------+ *
 * | Prologue section, copied to output source file: | *
 * +-------------------------------------------------+ */

/*
 * NOTE: Flex version 2.6 or higher recommended.
 */

#define INC_LEXER 1
#include "common.hpp"
#undef  INC_LEXER

namespace moon
{

// ========================================================
// Miscellaneous macros used by the generated code:
// ========================================================

// Note that these logging macros capture the current context,
// so they can only be called from within the FlexLexer class.
// Enabling these can be useful for debugging the lexer.
#if MOON_DUMP_LEXER_TOKENS
    #ifndef MOON_LEXER_LOG_STREAM
        #define MOON_LEXER_LOG_STREAM stdout
    #endif // MOON_LEXER_LOG_STREAM
    #define LEX_LOG_COMMENT(msg)  std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_CM](%02i): '%s'\n", lineno(), (msg))
    #define LEX_LOG_TOKEN(token)  std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_TK](%02i): '%s'\n", (yylineno), (token))
    #define LEX_LOG_TYPE(type)    std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_TP](%02i): '%s'\n", (yylineno), (type))
    #define LEX_LOG_KEYW(keyword) std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_KW](%02i): '%s'\n", (yylineno), (keyword))
    #define LEX_LOG_IDENT()       std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_ID](%02i): '%s'\n", (yylineno), (yytext))
    #define LEX_LOG_LIT(type)     std::fprintf(MOON_LEXER_LOG_STREAM, "[LEX_LI](%02i): '%s' (%s)\n", (yylineno), (yytext), (type))
#else // !MOON_DUMP_LEXER_TOKENS
    #define LEX_LOG_COMMENT(msg)
    #define LEX_LOG_TOKEN(token)
    #define LEX_LOG_TYPE(type)
    #define LEX_LOG_KEYW(keyword)
    #define LEX_LOG_IDENT()
    #define LEX_LOG_LIT(type)
#endif // MOON_DUMP_LEXER_TOKENS

// We are forced to cast the yyFlexLexer 'this' pointer to our moon::Lexer when
// calling the helper methods or using the extended ParseContext member. I do not know
// of a more elegant way of handling this with the generated FlexLexer code at the moment...
#define AS_MOON_LEXER(ptr) (*static_cast<moon::Lexer *>(ptr))

// Overwritten so we can capture the input to
// remember the current line for error printing.
#define YY_INPUT(buf, result, maxSize) AS_MOON_LEXER(this).lexOnInput((char *)buf, result, maxSize)

// Calls our custom error handler (called by FlexLexer).
#define YY_FATAL_ERROR(message) AS_MOON_LEXER(this).lexOnError(message)

// ========================================================
// moon::Lexer local methods:
// ========================================================

void Lexer::lexOnError(const char * message)
{
    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    compilerError(message, filename, lineno(), ctx.currText);
    throw LexerException{ "Lexer error" };
}

void Lexer::lexOnInput(char * buf, int & result, const int maxSize)
{
    const auto readCount = LexerInput(buf, maxSize);
    if (readCount < 0)
    {
        YY_FATAL_ERROR("lexer input failed");
    }
    if (ctx.currText != nullptr && readCount > 0)
    {
        ctx.currText->append(buf, readCount);
    }
    result = readCount;
}

void Lexer::lexOnNewLine()
{
    if (ctx.currText != nullptr)
    {
        ctx.currText->clear();
    }
}

void Lexer::lexOnSingleLineComment()
{
    int ch;
    LEX_LOG_COMMENT("Skipping single-line comment");
    while ((ch = yyinput()) != '\n' && ch != YY_NULL) { }
}

void Lexer::lexOnMultiLineComment()
{
    LEX_LOG_COMMENT("Skipping multi-line comment");
    for (int ch;;)
    {
        while ((ch = yyinput()) != '*' && ch != YY_NULL)
        {
            // Skip chars until the next '*' or EOF.
        }
        if (ch == '*')
        {
            while ((ch = yyinput()) == '*')
            {
                // Eat up any '*' that follow the first one.
            }
            if (ch == '/')
            {
                break; // Found the comment's end.
            }
        }
        if (ch == YY_NULL)
        {
            YY_FATAL_ERROR("unexpected end-of-file while scanning multi-line comment");
            break;
        }
    }
}

// ========================================================
// moon::Lexer Symbol/token handlers:
// ========================================================

#define LEX_DEFINE_SYMBOL_HANDLER(handlerName, findMethod, addMethod) \
    void Lexer::handlerName()                                         \
    {                                                                 \
        MOON_ASSERT(ctx.yylval   != nullptr);                         \
        MOON_ASSERT(ctx.symTable != nullptr);                         \
        auto sym = ctx.symTable->findMethod(YYText());                \
        if (sym == nullptr)                                           \
        {                                                             \
            sym = ctx.symTable->addMethod(YYText(), lineno());        \
        }                                                             \
        ctx.yylval->asSymbol = sym;                                   \
    }

LEX_DEFINE_SYMBOL_HANDLER( lexOnIdentifier,   findSymbol,       addIdentifier   );
LEX_DEFINE_SYMBOL_HANDLER( lexOnStrLiteral,   findStrLiteral,   addStrLiteral   );
LEX_DEFINE_SYMBOL_HANDLER( lexOnIntLiteral,   findIntLiteral,   addIntLiteral   );
LEX_DEFINE_SYMBOL_HANDLER( lexOnFloatLiteral, findFloatLiteral, addFloatLiteral );
LEX_DEFINE_SYMBOL_HANDLER( lexOnBoolLiteral,  findBoolLiteral,  addBoolLiteral  );
#undef LEX_DEFINE_SYMBOL_HANDLER

} // namespace moon {}

%}

/* +-------------------------------------------------+ *
 * | Macros used by the rules (regular expressions): | *
 * +-------------------------------------------------+ */

LETTER        [a-z_A-Z]
DIGIT         [0-9]
HEXA_PREFIX   ("0x"|"0X")
HEXA_CHAR     [a-fA-F]
EXPONENT      [eE][+-]?{DIGIT}+
FRACT         "."{DIGIT}+
INT_LITERAL   -?({DIGIT}|{HEXA_PREFIX})({DIGIT}|{HEXA_CHAR})*
FLT_LITERAL   -?{DIGIT}+{FRACT}{EXPONENT}?
BOOL_LITERAL  ("true"|"false")
STR_LITERAL   \"[^\"]*\"
IDENTIFIER    {LETTER}({LETTER}|{DIGIT}|".")*
WHITE_SPACE   [ \t\f\v]
NEW_LINE      [\n\r]

/* +-------------------------------------------------+ *
 * | The lexer rules (language tokens / leaf nodes): | *
 * +-------------------------------------------------+ */

%%

    /* ---- Comments and whitespace: ---- */
{WHITE_SPACE}    { }                                               /* Whitespace ignored                               */
{NEW_LINE}       { AS_MOON_LEXER(this).lexOnNewLine();           } /* Keep track of the latest line for error printing */
"//"             { AS_MOON_LEXER(this).lexOnSingleLineComment(); } /* C++ style single line comment                    */
"/*"             { AS_MOON_LEXER(this).lexOnMultiLineComment();  } /* C-style multi-line comment block                 */
"*/"             { YY_FATAL_ERROR("unmatched end of multi-line comment block"); }

    /* ---- Miscellaneous tokens and operators: ---- */
"("              { LEX_LOG_TOKEN( "("   ); return moon::Parser::token::OPEN_PAR;             }
")"              { LEX_LOG_TOKEN( ")"   ); return moon::Parser::token::CLOSE_PAR;            }
"{"              { LEX_LOG_TOKEN( "{"   ); return moon::Parser::token::OPEN_CBRAC;           }
"}"              { LEX_LOG_TOKEN( "}"   ); return moon::Parser::token::CLOSE_CBRAC;          }
"["              { LEX_LOG_TOKEN( "["   ); return moon::Parser::token::OPEN_BRAC;            }
"]"              { LEX_LOG_TOKEN( "]"   ); return moon::Parser::token::CLOSE_BRAC;           }
","              { LEX_LOG_TOKEN( ","   ); return moon::Parser::token::COMMA;                }
";"              { LEX_LOG_TOKEN( ";"   ); return moon::Parser::token::SEMICOLON;            }
":"              { LEX_LOG_TOKEN( ":"   ); return moon::Parser::token::COLON;                }
".."             { LEX_LOG_TOKEN( ".."  ); return moon::Parser::token::RANGE;                }
"..."            { LEX_LOG_TOKEN( "..." ); return moon::Parser::token::VARARGS;              }
"->"             { LEX_LOG_TOKEN( "->"  ); return moon::Parser::token::ARROW;                }
"="              { LEX_LOG_TOKEN( "="   ); return moon::Parser::token::OP_ASSIGN;            }
"+"              { LEX_LOG_TOKEN( "+"   ); return moon::Parser::token::OP_PLUS;              }
"-"              { LEX_LOG_TOKEN( "-"   ); return moon::Parser::token::OP_MINUS;             }
"*"              { LEX_LOG_TOKEN( "*"   ); return moon::Parser::token::OP_MULTIPLY;          }
"/"              { LEX_LOG_TOKEN( "/"   ); return moon::Parser::token::OP_DIVIDE;            }
"%"              { LEX_LOG_TOKEN( "%"   ); return moon::Parser::token::OP_MODULO;            }
"+="             { LEX_LOG_TOKEN( "+="  ); return moon::Parser::token::OP_PLUS_EQUAL;        }
"-="             { LEX_LOG_TOKEN( "-="  ); return moon::Parser::token::OP_MINUS_EQUAL;       }
"*="             { LEX_LOG_TOKEN( "*="  ); return moon::Parser::token::OP_MULTIPLY_EQUAL;    }
"/="             { LEX_LOG_TOKEN( "/="  ); return moon::Parser::token::OP_DIVIDE_EQUAL;      }
"%="             { LEX_LOG_TOKEN( "%="  ); return moon::Parser::token::OP_MODULO_EQUAL;      }
">"              { LEX_LOG_TOKEN( ">"   ); return moon::Parser::token::OP_CMP_GREATER_THAN;  }
"<"              { LEX_LOG_TOKEN( "<"   ); return moon::Parser::token::OP_CMP_LESS_THAN;     }
">="             { LEX_LOG_TOKEN( ">="  ); return moon::Parser::token::OP_CMP_GREATER_EQUAL; }
"<="             { LEX_LOG_TOKEN( "<="  ); return moon::Parser::token::OP_CMP_LESS_EQUAL;    }
"=="             { LEX_LOG_TOKEN( "=="  ); return moon::Parser::token::OP_CMP_EQUAL;         }
"!="             { LEX_LOG_TOKEN( "!="  ); return moon::Parser::token::OP_CMP_NOT_EQUAL;     }
"and"            { LEX_LOG_TOKEN( "and" ); return moon::Parser::token::OP_LOGIC_AND;         }
"or"             { LEX_LOG_TOKEN( "or"  ); return moon::Parser::token::OP_LOGIC_OR;          }
"not"            { LEX_LOG_TOKEN( "not" ); return moon::Parser::token::OP_LOGIC_NOT;         }

    /* ---- Built-in types: ---- */
"int"            { LEX_LOG_TYPE( "int"      ); return moon::Parser::token::TID_INT;          }
"long"           { LEX_LOG_TYPE( "long"     ); return moon::Parser::token::TID_LONG;         }
"float"          { LEX_LOG_TYPE( "float"    ); return moon::Parser::token::TID_FLT;          }
"bool"           { LEX_LOG_TYPE( "bool"     ); return moon::Parser::token::TID_BOOL;         }
"string"         { LEX_LOG_TYPE( "string"   ); return moon::Parser::token::TID_STR;          }
"array"          { LEX_LOG_TYPE( "array"    ); return moon::Parser::token::TID_ARRAY;        }
"range"          { LEX_LOG_TYPE( "range"    ); return moon::Parser::token::TID_RANGE;        }
"any"            { LEX_LOG_TYPE( "any"      ); return moon::Parser::token::TID_ANY;          }

    /* ---- Language keywords: ---- */
"if"             { LEX_LOG_KEYW( "if"       ); return moon::Parser::token::KW_IF;            }
"then"           { LEX_LOG_KEYW( "then"     ); return moon::Parser::token::KW_THEN;          }
"else"           { LEX_LOG_KEYW( "else"     ); return moon::Parser::token::KW_ELSE;          }
"elseif"         { LEX_LOG_KEYW( "elseif"   ); return moon::Parser::token::KW_ELSEIF;        }
"end"            { LEX_LOG_KEYW( "end"      ); return moon::Parser::token::KW_END;           }
"return"         { LEX_LOG_KEYW( "return"   ); return moon::Parser::token::KW_RETURN;        }
"let"            { LEX_LOG_KEYW( "let"      ); return moon::Parser::token::KW_LET;           }
"func"           { LEX_LOG_KEYW( "func"     ); return moon::Parser::token::KW_FUNC;          }
"match"          { LEX_LOG_KEYW( "match"    ); return moon::Parser::token::KW_MATCH;         }
"with"           { LEX_LOG_KEYW( "with"     ); return moon::Parser::token::KW_WITH;          }
"case"           { LEX_LOG_KEYW( "case"     ); return moon::Parser::token::KW_CASE;          }
"default"        { LEX_LOG_KEYW( "default"  ); return moon::Parser::token::KW_DEFAULT;       }
"in"             { LEX_LOG_KEYW( "in"       ); return moon::Parser::token::KW_IN;            }
"do"             { LEX_LOG_KEYW( "do"       ); return moon::Parser::token::KW_DO;            }
"for"            { LEX_LOG_KEYW( "for"      ); return moon::Parser::token::KW_FOR;           }
"while"          { LEX_LOG_KEYW( "while"    ); return moon::Parser::token::KW_WHILE;         }
"loop"           { LEX_LOG_KEYW( "loop"     ); return moon::Parser::token::KW_LOOP;          }
"break"          { LEX_LOG_KEYW( "break"    ); return moon::Parser::token::KW_BREAK;         }
"continue"       { LEX_LOG_KEYW( "continue" ); return moon::Parser::token::KW_CONTINUE;      }
"type"           { LEX_LOG_KEYW( "type"     ); return moon::Parser::token::KW_TYPE;          }
"enum"           { LEX_LOG_KEYW( "enum"     ); return moon::Parser::token::KW_ENUM;          }
"struct"         { LEX_LOG_KEYW( "struct"   ); return moon::Parser::token::KW_STRUCT;        }
"module"         { LEX_LOG_KEYW( "module"   ); return moon::Parser::token::KW_MODULE;        }

    /* ---- Literal constants: ---- */
{INT_LITERAL}    { LEX_LOG_LIT( "int-literal"     ); AS_MOON_LEXER(this).lexOnIntLiteral();   return moon::Parser::token::INT_LITERAL;  }
{FLT_LITERAL}    { LEX_LOG_LIT( "float-literal"   ); AS_MOON_LEXER(this).lexOnFloatLiteral(); return moon::Parser::token::FLT_LITERAL;  }
{BOOL_LITERAL}   { LEX_LOG_LIT( "boolean-literal" ); AS_MOON_LEXER(this).lexOnBoolLiteral();  return moon::Parser::token::BOOL_LITERAL; }
{STR_LITERAL}    { LEX_LOG_LIT( "string-literal"  ); AS_MOON_LEXER(this).lexOnStrLiteral();   return moon::Parser::token::STR_LITERAL;  }

    /* ---- Identifies/names: ---- */
{IDENTIFIER}     { LEX_LOG_IDENT(); AS_MOON_LEXER(this).lexOnIdentifier(); return moon::Parser::token::IDENTIFIER; }

    /* ---- Anything not listed above is an error, handled by the special '.' rule: ---- */
.                { YY_FATAL_ERROR("invalid token"); }

%%
