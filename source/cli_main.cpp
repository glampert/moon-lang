
// ================================================================================================
// -*- C++ -*-
// File: cli_main.cpp
// Author: Guilherme R. Lampert
// Created on: 10/03/16
// Brief: Command-line interpreter entry point.
// ================================================================================================

#include "compiler.hpp"
#include "vm.hpp"

/*
=================================================
TODO LIST:

- Should test this on a tool like Valgrind or Clang Mem Sanitizer to check for possible leaks!!!

- Script exceptions should probably carry a script stack trace with them.

- GC

- Organize the makefile.

- Add the generated files to the repo, in case trying to compile without bison&flex.

=================================================
*/

using namespace moon;

// ================================================================================================
// TEMP. this will be moved to the CG or runtime.cpp ...

#ifndef MOON_RT_OBJECT_POOL_GRANULARITY
    #define MOON_RT_OBJECT_POOL_GRANULARITY 512
#endif // MOON_RT_OBJECT_POOL_GRANULARITY

template<typename T>
constexpr T maxOf2(T a, T b) { return (a > b) ? a : b; }

template<typename T>
constexpr T maxOfN(T x) { return x; }

template<typename T, typename... Args>
constexpr T maxOfN(T x, Args... args) { return maxOf2(x, maxOfN(args...)); }

template<typename... Objects>
struct RtObjMemoryBlobImpl final
{
    static constexpr UInt32 LargestSize  = maxOfN(sizeof(Objects)...);
    static constexpr UInt32 LargestAlign = maxOfN(alignof(Objects)...);

    alignas(LargestAlign) UInt8 blob[LargestSize];
};

// Actually, might want to separate Str and Array from the rest.
// Str and Array are ~128Bytes, we can probably fit the rest in under 64
using RtObjMemoryBlob =
    RtObjMemoryBlobImpl
    <
        Object,
        Struct,
        Enum,
        Str,
        Array
    >;
using RuntimeObjectPool = Pool<RtObjMemoryBlob, MOON_RT_OBJECT_POOL_GRANULARITY>;

// ================================================================================================

int main(const int argc, const char * argv[])
{
    try
    {
        moon::VM       vm;       // Executes the bytecode generated by a Compiler.
        moon::Compiler compiler; // Parses scripts and generates VM bytecode.

        if (argc > 1)
        {
            compiler.parseScript(&vm, argv[1]);
        }
        else
        {
            compiler.parseScript(&vm, "test.ml");
        }

        logStream() << compiler.symTable << "\n";
        logStream() << compiler.syntTree << "\n";
        logStream() << vm.functions << "\n";

        compiler.compile(&vm);
        logStream() << compiler << "\n";
        //logStream() << vm.code << "\n";

        vm.execute();
        logStream() << vm << "\n";

        /*
        logStream() << "----------------------------------\n";
        logStream() << "GC OBJECTS:\n\n";
        for (const Object * obj = vm.gc.getGCListHead(); obj != nullptr; obj = obj->getGCLink())
        {
            obj->print(logStream());
            logStream() << "\n";
        }
        logStream() << "----------------------------------\n";
        //*/
    }
    catch (const moon::BaseException & e)
    {
    }
}
