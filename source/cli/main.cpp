
// ================================================================================================
// -*- C++ -*-
// File: main.cpp
// Author: Guilherme R. Lampert
// Created on: 10/03/16
// Brief: Command-line interpreter entry point.
// ================================================================================================

#include "compiler.hpp"
#include "vm.hpp"

/*
=================================================
TODO LIST:

- Should test this on a tool like Valgrind or Clang Mem Sanitizer to check for possible leaks!!!

- Add the generated files to the repo, in case trying to compile without bison&flex.

- GC

=================================================
*/

using namespace moon;

// ================================================================================================
// TEMP. this will be moved to the CG or runtime.cpp ...

#ifndef MOON_RT_OBJECT_POOL_GRANULARITY
    #define MOON_RT_OBJECT_POOL_GRANULARITY 256
#endif // MOON_RT_OBJECT_POOL_GRANULARITY

template<typename... Objects>
struct RtObjMemoryBlobImpl final
{
    static constexpr UInt32 LargestSize  = ct::maxOfN(sizeof(Objects)...);
    static constexpr UInt32 LargestAlign = ct::maxOfN(alignof(Objects)...);

    alignas(LargestAlign) UInt8 blob[LargestSize];
};

using RtObjMemoryBlobSmall   = RtObjMemoryBlobImpl<Object, Struct, Enum>;
using RtObjMemoryBlobBig     = RtObjMemoryBlobImpl<Str, Array>;

using SmallRuntimeObjectPool = Pool<RtObjMemoryBlobSmall, MOON_RT_OBJECT_POOL_GRANULARITY>;
using BigRuntimeObjectPool   = Pool<RtObjMemoryBlobBig,   MOON_RT_OBJECT_POOL_GRANULARITY>;

// ================================================================================================

int main(const int argc, const char * argv[])
{
    moon::VM       vm;       // Executes the bytecode generated by a Compiler.
    moon::Compiler compiler; // Parses scripts and generates VM bytecode.

    std::cout << "sizeof(RtObjMemoryBlobSmall) = " << sizeof(RtObjMemoryBlobSmall) << "\n";
    std::cout << "sizeof(RtObjMemoryBlobBig)   = " << sizeof(RtObjMemoryBlobBig) << "\n";

    try
    {
        if (argc > 1)
        {
            compiler.parseScript(&vm, argv[1]);
        }
        else
        {
            compiler.parseScript(&vm, "test.ml");
        }

        logStream() << compiler.symTable << "\n";
        logStream() << compiler.syntTree << "\n";
        logStream() << vm.functions << "\n";

        compiler.compile(&vm);
        logStream() << compiler << "\n";
        logStream() << vm.code << "\n";

        vm.execute();

        //vm.execute(11, 8);
        //logStream() << "PC=" << vm.getProgramCounter() << "\n";

// cpp_call.ml
#if 0
        logStream() << "FIRST RUN:\n";
        vm.execute();

        Variant retVal;
        Variant arg0, arg1, arg2;

        logStream() << "\nCALLING:\n\n";

        // Void function that returns void:
        {
            retVal = vm.call("script_func0");
            MOON_ASSERT(retVal.isNull());
        }

        // Function taking 1 argument:
        {
            arg0.type = Variant::Type::Integer;
            arg0.value.asInteger = 1337;

            retVal = vm.call("script_func1", { arg0 });
            MOON_ASSERT(retVal.type == Variant::Type::Integer && retVal.value.asInteger == 321);
        }

        // Function taking 2 arguments:
        {
            arg0.type = Variant::Type::Integer;
            arg0.value.asInteger = 42;

            arg1.type = Variant::Type::Float;
            arg1.value.asFloat = 2.7;

            retVal = vm.call("script_func2", { arg0, arg1 });
            MOON_ASSERT(retVal.type == Variant::Type::Float && retVal.value.asFloat == -1.5);
        }

        // Function taking 3 arguments:
        {
            arg0.type = Variant::Type::Integer;
            arg0.value.asInteger = 33;

            arg1.type = Variant::Type::Float;
            arg1.value.asFloat = -0.5;

            arg2.type = Variant::Type::Str;
            const char * s = "hello from C++";
            arg2.value.asString = Str::newFromString(vm, s, std::strlen(s), true);

            retVal = vm.call("script_func3", { arg0, arg1, arg2 });
            MOON_ASSERT(retVal.type == Variant::Type::Str && std::strcmp("testing, 123", retVal.value.asString->c_str()) == 0);
        }

        // Varargs function:
        {
            arg0.type = Variant::Type::Integer;
            arg0.value.asInteger = 666;

            arg1.type = Variant::Type::Range;
            arg1.value.asRange.begin = -5;
            arg1.value.asRange.end   = 10;

            arg2.type = Variant::Type::Str;
            const char * s = "hello from C++, again";
            arg2.value.asString = Str::newFromString(vm, s, std::strlen(s), true);

            retVal = vm.call("script_func_varargs", { arg0, arg1, arg2 });
            MOON_ASSERT(retVal.isNull()); // Returns nothing.
        }

        // Call a native function by name:
        {
            arg0.type = Variant::Type::Str;
            const char * s = "native function called from C++; ";
            arg0.value.asString = Str::newFromString(vm, s, std::strlen(s), true);

            arg1.type = Variant::Type::Float;
            arg1.value.asFloat = 2.345;

            retVal = vm.call("println", { arg0, arg1 });
            MOON_ASSERT(retVal.isNull());
        }

#endif // 0

// globals.ml
#if 0
        // init the globals
        logStream() << "FIRST RUN:\n";
        vm.execute();

        logStream() << "CALLING:\n";
        vm.call("print_globals");

        //logStream() << "RE-RUN:\n";
        //vm.execute();

        //*
        //logStream() << "\nB4:\n";
        //printDataVector(vm.data, logStream());
        //vm.globals.print(logStream());

        Variant var;

        var.type = Variant::Type::Integer;
        var.value.asInteger = 1337;
        MOON_ASSERT(vm.globals.setGlobal("an_integer", var) == true);

        var.type = Variant::Type::Float;
        var.value.asFloat = 3.141592;
        MOON_ASSERT(vm.globals.setGlobal("a_float", var) == true);

        var.type = Variant::Type::Range;
        var.value.asRange.begin = -5;
        var.value.asRange.end   = +5;
        MOON_ASSERT(vm.globals.setGlobal("a_range", var) == true);

        var.type = Variant::Type::Str;
        const char * s = "hello from C++";
        var.value.asString = Str::newFromString(vm, s, std::strlen(s), true);
        MOON_ASSERT(vm.globals.setGlobal("a_string", var) == true);

        //logStream() << "\nAFTER:\n";
        //printDataVector(vm.data, logStream());
        //vm.globals.print(logStream());
        //*/

        //vm.globals.print(logStream());
        //logStream() << vm << "\n";

        logStream() << "CALLING:\n";
        vm.call("print_globals");
#endif // 0

        /*
        logStream() << "----------------------------------\n";
        logStream() << "GC OBJECTS:\n\n";
        for (const Object * obj = vm.gc.getGCListHead(); obj != nullptr; obj = obj->getGCLink())
        {
            obj->print(logStream());
            logStream() << "\n";
        }
        logStream() << "----------------------------------\n";
        //*/
    }
    catch (const moon::BaseException & e)
    {
        #if MOON_SAVE_SCRIPT_CALLSTACK
        vm.printStackTrace(logStream());
        #endif // MOON_SAVE_SCRIPT_CALLSTACK
    }
}
