
/*
 * NOTE: Bison version 3.0 or higher recommended.
 * https://www.gnu.org/software/bison/manual/html_node/index.html
 */

/* +-------------------------------------------------+ *
 * | Bison configuration parameters:                 | *
 * +-------------------------------------------------+ */

%skeleton "lalr1.cc"
%defines

%define parse.assert true
%define parse.error  verbose

%define api.namespace     {moon}
%define parser_class_name {Parser}

%parse-param {ParseContext & ctx}
%lex-param   {ParseContext & ctx}

%{
/*
 * Nothing to be added in the prologue section at the moment.
 * Left it here because Vim's syntax highlighting gets messed
 * up if this section is missing.
 *
 * Most of the stuff depends on the header file, so they
 * must be placed inside the %code { } section.
 */
%}

/* +-------------------------------------------------+ *
 * | Additional verbatin code sections:              | *
 * +-------------------------------------------------+ */

/*
 * 'Requires' section is added to generated parser header file.
 * Good place for forward declaration and types used in the yylval union.
 */
%code requires
{

#define INC_PARSER 1
#include "common.hpp"
#undef  INC_PARSER

} /* %code requires */

/*
 * The unqualified code section is added to the implementation file, after
 * the parser header is included, which is the right place for these.
 */
%code
{

#include "symbol_table.hpp"
#include "syntax_tree.hpp"
#include "vm.hpp"

namespace moon
{

using STNode = SyntaxTreeNode::Type;
using STEval = SyntaxTreeNode::Eval;

// ------------------------------------------------------------------

[[noreturn]] static void parserError(ParseContext & ctx, const std::string & message) noexcept(false)
{
    MOON_ASSERT(ctx.lexer != nullptr);
    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    parserError(message, filename, ctx.lexer->lineno(), ctx.currText);
}

static bool g_enableWarnings = true;

static void parserWarn(ParseContext & ctx, const std::string & message)
{
    MOON_ASSERT(ctx.lexer != nullptr);
    if (!g_enableWarnings) { return; }
    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    warning(message, filename, ctx.lexer->lineno(), ctx.currText);
}

// ------------------------------------------------------------------

//FIXME temp; testing this new stuff...
//TODO remove the debug printfs!

struct VarInfo final
{
    const TypeId * const       typeId;
    const Variant::Type        varType;
    const SyntaxTreeNode::Eval arrayEval; // Only applicable it varType=Array, otherwise Null.
    const SyntaxTreeNode::Eval stEval;
};

// [var_symbol, var_info]
using VarInfoTable = HashTable<const Symbol *, VarInfo>;
static VarInfoTable * g_globalVars = new VarInfoTable{};
static VarInfoTable * g_localVars  = nullptr;

static const Symbol * g_currentFunction = nullptr;
static const Symbol * g_currentUDT = nullptr;

static STEval g_expectedReturnType = STEval::Void;

static const TypeId * g_lastRhsTypeId = nullptr;

static bool g_debugMode = true; //TODO when true, calls to debug functions (like assert) get stripped!

static bool isParsingFunction() noexcept { return g_currentFunction != nullptr; }
static bool isParsingUDT()      noexcept { return g_currentUDT != nullptr; }

static const VarInfo * findFunctionLocalVar(const Symbol * symbol)
{
    MOON_ASSERT(g_localVars != nullptr);

    const auto & iter = g_localVars->find(symbol);
    if (iter != g_localVars->end())
    {
        return &(iter->second);
    }
    return nullptr;
}

static const VarInfo * findGlobalVar(const Symbol * symbol)
{
    MOON_ASSERT(g_globalVars != nullptr);

    const auto iter = g_globalVars->find(symbol);
    if (iter != g_globalVars->end())
    {
        return &(iter->second);
    }
    return nullptr;
}

static void requireGlobalScope(ParseContext & ctx, const char * elementName)
{
    if (isParsingFunction() || isParsingUDT())
    {
        parserError(ctx, toString(elementName) + " can only be declared at the global scope");
    }
}

static void beginFunc(ParseContext & ctx, const Symbol * funcNameSymbol)
{
    if (isParsingFunction())
    {
        parserError(ctx, "nested functions are currently unsupported");
    }
    if (isParsingUDT())
    {
        parserError(ctx, "member functions are currently unsupported");
    }

    g_localVars        = new VarInfoTable{};
    g_currentFunction  = funcNameSymbol;

    printf("BEGIN FUNC %s\n", g_currentFunction->name->chars);
}

static void endFunc(ParseContext & ctx)
{
    (void)ctx;
    printf("END FUNC %s\n", g_currentFunction->name->chars);

    g_localVars          = nullptr;
    g_currentFunction    = nullptr;
    g_expectedReturnType = STEval::Void;
}

static void beginUDT(ParseContext & ctx, const Symbol * typeNameSymbol, const char * elementName)
{
    requireGlobalScope(ctx, elementName);
    g_currentUDT = typeNameSymbol;

    printf("BEGIN UDT %s\n", g_currentUDT->name->chars);
}

static void endUDT(ParseContext & ctx)
{
    (void)ctx;
    printf("END UDT %s\n", g_currentUDT->name->chars);

    g_currentUDT = nullptr;
}

// ------------------------------------------------------------------

//
// Type conversion helpers:
//

static STEval varType2Eval(const Variant::Type varType)
{
    switch (varType)
    {
    case Variant::Type::Null     : return STEval::Null;
    case Variant::Type::Integer  : return STEval::Long;
    case Variant::Type::Float    : return STEval::Double;
    case Variant::Type::Function : return STEval::Func;
    case Variant::Type::Tid      : return STEval::Tid;
    case Variant::Type::Str      : return STEval::Str;
    case Variant::Type::Object   : return STEval::UDT;
    case Variant::Type::Array    : return STEval::Array;
    case Variant::Type::Range    : return STEval::Range;
    case Variant::Type::Any      : return STEval::Any;
    default : MOON_INTERNAL_EXCEPTION("can't convert Variant type '" + toString(varType) + "' to STEval!");
    } // switch (varType)
}

static const TypeId * varType2TypeId(const TypeTable & typeTable, const Variant::Type varType)
{
    switch (varType)
    {
    case Variant::Type::Null     : return typeTable.nullTypeId;
    case Variant::Type::Integer  : return typeTable.longTypeId;
    case Variant::Type::Float    : return typeTable.doubleTypeId;
    case Variant::Type::Function : return typeTable.functionTypeId;
    case Variant::Type::Tid      : return typeTable.tidTypeId;
    case Variant::Type::Str      : return typeTable.strTypeId;
    case Variant::Type::Object   : return typeTable.objectTypeId;
    case Variant::Type::Array    : return typeTable.arrayTypeId;
    case Variant::Type::Range    : return typeTable.rangeTypeId;
    case Variant::Type::Any      : return typeTable.anyTypeId;
    default : MOON_INTERNAL_EXCEPTION("can't convert Variant type '" + toString(varType) + "' to STEval!");
    } // switch (varType)
}

static Variant::Type eval2VarType(const STEval stEval)
{
    switch (stEval)
    {
    case STEval::Null   : return Variant::Type::Null;
    case STEval::Int    : return Variant::Type::Integer;
    case STEval::Long   : return Variant::Type::Integer;
    case STEval::Float  : return Variant::Type::Float;
    case STEval::Double : return Variant::Type::Float;
    case STEval::Bool   : return Variant::Type::Integer;
    case STEval::Str    : return Variant::Type::Str;
    case STEval::Array  : return Variant::Type::Array;
    case STEval::Range  : return Variant::Type::Range;
    case STEval::Any    : return Variant::Type::Any;
    case STEval::Func   : return Variant::Type::Function;
    case STEval::Tid    : return Variant::Type::Tid;
    case STEval::UDT    : return Variant::Type::Object;
    default : MOON_INTERNAL_EXCEPTION("can't convert STEval '" + toString(stEval) + "' to Variant type!");
    } // switch (stEval)
}

static const TypeId * eval2TypeId(const TypeTable & typeTable, const STEval stEval)
{
    switch (stEval)
    {
    case STEval::Null   : return typeTable.nullTypeId;
    case STEval::Int    : return typeTable.intTypeId;
    case STEval::Long   : return typeTable.longTypeId;
    case STEval::Float  : return typeTable.floatTypeId;
    case STEval::Double : return typeTable.doubleTypeId;
    case STEval::Bool   : return typeTable.boolTypeId;
    case STEval::Str    : return typeTable.strTypeId;
    case STEval::Array  : return typeTable.arrayTypeId;
    case STEval::Range  : return typeTable.rangeTypeId;
    case STEval::Any    : return typeTable.anyTypeId;
    case STEval::Func   : return typeTable.functionTypeId;
    case STEval::Tid    : return typeTable.tidTypeId;
    case STEval::UDT    : return typeTable.objectTypeId;
    default : MOON_INTERNAL_EXCEPTION("can't convert STEval '" + toString(stEval) + "' to TypeId!");
    } // switch (stEval)
}

static STEval symbol2Eval(const Symbol & symbol)
{
    switch (symbol.type)
    {
    case Symbol::Type::IntLiteral   : return SyntaxTreeNode::Eval::Long;
    case Symbol::Type::FloatLiteral : return SyntaxTreeNode::Eval::Double;
    case Symbol::Type::BoolLiteral  : return SyntaxTreeNode::Eval::Bool;
    case Symbol::Type::StrLiteral   : return SyntaxTreeNode::Eval::Str;
    case Symbol::Type::Identifier   : return SyntaxTreeNode::Eval::UDT;
    default : MOON_INTERNAL_EXCEPTION("can't convert symbol '" + toString(symbol.type) + "' to STEval!");
    } // switch (symbol.type)
}

// From compiler.cpp
extern const Symbol * symbolFromEval(const SymbolTable & symTable, SyntaxTreeNode::Eval stEval);

// ------------------------------------------------------------------

static void registerVariable(ParseContext & ctx,
                             const Symbol * nameSymbol,
                             const SyntaxTreeNode * initNode,
                             const SyntaxTreeNode * typeNode,
                             const STEval stEval, VarInfoTable & destTable)
{
    const SyntaxTreeNode * tidNode = nullptr;

    if (typeNode != nullptr)
    {
        tidNode = typeNode;
    }
    else if (initNode != nullptr)
    {
        tidNode = initNode;
    }
    else
    {
        parserError(ctx, "variable declaration requires an initializer");
    }

    const auto typeId = (stEval == STEval::UDT) ?
        ctx.vm->types.findTypeId(tidNode->symbol->name) :
        eval2TypeId(ctx.vm->types, stEval);

    if (typeId == nullptr)
    {
        std::string tname = color::white() + toString(tidNode->symbol->name) + color::restore();
        parserError(ctx, "cannot declare variable of undefined type '" + tname + "'");
    }

    const auto varType   = eval2VarType(stEval);
    const auto arrayEval = ((varType == Variant::Type::Array && initNode != nullptr) ?
                             initNode->getChild(2)->evalType : STEval::Null);

    destTable.insert(std::make_pair(nameSymbol, VarInfo{ typeId, varType, arrayEval, stEval }));

    printf("ADDING VAR: %s, %s, %s, %s (arrayT=%s)\n", nameSymbol->name->chars, toString(stEval).c_str(),
           toString(typeId->name).c_str(), toString(eval2VarType(stEval)).c_str(), toString(arrayEval).c_str());
}

// ------------------------------------------------------------------

static STEval registerGlobalOrLocal(ParseContext & ctx, const Symbol * nameSymbol, SyntaxTreeNode * initNode,
                                    const SyntaxTreeNode * typeNode, STEval stEval)
{
    if (!isParsingFunction()) // Global scope or parsing a function declaration?
    {
        MOON_ASSERT(g_globalVars != nullptr);

        if (stEval == STEval::Undefined)
        {
            if (initNode == nullptr || initNode->symbol == nullptr)
            {
                parserError(ctx, "variable declaration requires an initializer");
            }

            // A global can be initialized from other globals
            const auto globIter = g_globalVars->find(initNode->symbol);
            if (globIter == g_globalVars->end())
            {
                std::string srcName = color::white() + toString(nameSymbol->name) + color::restore();
                std::string dstName = color::white() + toString(initNode->symbol->name) + color::restore();
                parserError(ctx, "initializing global variable '" + srcName + "' from unknown identifier '" + dstName + "'");
            }

            stEval = globIter->second.stEval;
            initNode->evalType = stEval;
        }

        if (g_globalVars->find(nameSymbol) != g_globalVars->end())
        {
            std::string vname = color::white() + toString(nameSymbol->name) + color::restore();
            parserError(ctx, "redefinition of global variable '" + vname + "'");
        }

        registerVariable(ctx, nameSymbol, initNode, typeNode, stEval, *g_globalVars);
    }
    else
    {
        MOON_ASSERT(g_globalVars != nullptr);
        MOON_ASSERT(g_localVars  != nullptr);

        if (stEval == STEval::Undefined)
        {
            if (initNode == nullptr || initNode->symbol == nullptr)
            {
                parserError(ctx, "variable declaration requires an initializer");
            }

            // A local can be initialized from other locals or globals
            const auto globIter = g_globalVars->find(initNode->symbol);
            if (globIter == g_globalVars->end())
            {
                // Try from a previous local variable
                const auto localIter = g_localVars->find(initNode->symbol);
                if (localIter == g_localVars->end())
                {
                    std::string srcName = color::white() + toString(nameSymbol->name) + color::restore();
                    std::string dstName = color::white() + toString(initNode->symbol->name) + color::restore();
                    parserError(ctx, "initializing local variable '" + srcName + "' from unknown identifier '" + dstName + "'");
                }
                stEval = localIter->second.stEval;
            }
            else
            {
                stEval = globIter->second.stEval;
            }
            initNode->evalType = stEval;
        }

        if (g_localVars->find(nameSymbol) != g_localVars->end())
        {
            std::string vname = color::white() + toString(nameSymbol->name) + color::restore();
            parserError(ctx, "redefinition of local variable '" + vname + "'");
        }

        registerVariable(ctx, nameSymbol, initNode, typeNode, stEval, *g_localVars);
    }

    return stEval;
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newVarDeclNode(ParseContext & ctx, const Symbol * nameSymbol, SyntaxTreeNode * initNode,
                                       const SyntaxTreeNode * typeNode, STEval stEval)
{
    // Member vars get collected somewhere else.
    if (!isParsingUDT())
    {
        stEval = registerGlobalOrLocal(ctx, nameSymbol, initNode, typeNode, stEval);
    }
    return ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                           nameSymbol, initNode, typeNode,
                                           nullptr, stEval);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newLiteralNode(ParseContext & ctx, const STEval stEval, const Symbol * symbol)
{
    if (symbol == nullptr)
    {
        symbol = ctx.symTable->findOrDefineStrValue("null");
    }
    return ctx.syntTree->newNodeWithEval(STNode::ExprLiteralConst, symbol, stEval);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newTypeIdNode(ParseContext & ctx, const STEval stEval,
                                      const Symbol * symbol = nullptr)
{
    if (symbol == nullptr)
    {
        symbol = symbolFromEval(*ctx.symTable, stEval);
    }
    return ctx.syntTree->newNodeWithEval(STNode::ExprTypeIdent, symbol, stEval);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newCompareNode(ParseContext & ctx, const STNode type,
                                       const SyntaxTreeNode * child0,
                                       const SyntaxTreeNode * child1,
                                       const SyntaxTreeNode * child2)
{
    // Special 'if X then' case:
    if (child0->nodeType == STNode::ExprNameIdent)
    {
        // Turn it into a compare against zero/null/false expression:
        auto zeroNode = newLiteralNode(ctx, STEval::Long, ctx.symTable->findOrDefineIntValue(0));
        auto compNode = ctx.syntTree->newNode(STNode::ExprCmpNotEqual, child0, zeroNode);
        return ctx.syntTree->newNode(type, compNode, child1, child2);
    }
    // Normal 'if X comp Y then' case:
    return ctx.syntTree->newNode(type, child0, child1, child2);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newBinaryOpNode(ParseContext & ctx, const STNode type,
                                        SyntaxTreeNode * lhs, SyntaxTreeNode * rhs)
{
    OpCode  binOp;
    Variant result;

    switch (type)
    {
    case STNode::ExprAddAssign       : binOp = OpCode::Add;             break;
    case STNode::ExprSubAssign       : binOp = OpCode::Sub;             break;
    case STNode::ExprDivAssign       : binOp = OpCode::Div;             break;
    case STNode::ExprModAssign       : binOp = OpCode::Mod;             break;
    case STNode::ExprMulAssign       : binOp = OpCode::Mul;             break;
    case STNode::ExprAdd             : binOp = OpCode::Add;             break;
    case STNode::ExprSubtract        : binOp = OpCode::Sub;             break;
    case STNode::ExprDivide          : binOp = OpCode::Div;             break;
    case STNode::ExprModulo          : binOp = OpCode::Mod;             break;
    case STNode::ExprMultiply        : binOp = OpCode::Mul;             break;
    case STNode::ExprLogicOr         : binOp = OpCode::LogicOr;         break;
    case STNode::ExprLogicAnd        : binOp = OpCode::LogicAnd;        break;
    case STNode::ExprCmpNotEqual     : binOp = OpCode::CmpNotEqual;     break;
    case STNode::ExprCmpEqual        : binOp = OpCode::CmpEqual;        break;
    case STNode::ExprCmpGreaterEqual : binOp = OpCode::CmpGreaterEqual; break;
    case STNode::ExprCmpGreaterThan  : binOp = OpCode::CmpGreater;      break;
    case STNode::ExprCmpLessEqual    : binOp = OpCode::CmpLessEqual;    break;
    case STNode::ExprCmpLessThan     : binOp = OpCode::CmpLess;         break;
    case STNode::ExprAssign          : binOp = OpCode::StoreGlob;       break;
    case STNode::ExprMemberRef       : binOp = OpCode::MemberRef;       break;
    default : MOON_INTERNAL_EXCEPTION("unhandled STNode type " + toString(type) + " in binary op!");
    } // switch (type)

    if (binOp == OpCode::MemberRef) // Validate the object and member types
    {
        const TypeId * lhsTypeId = nullptr;
        if (lhs->nodeType != STNode::ExprMemberRef)
        {
            MOON_ASSERT(lhs->symbol != nullptr);
            const VarInfo * vi = isParsingFunction() ? findFunctionLocalVar(lhs->symbol) : findGlobalVar(lhs->symbol);
            if (vi == nullptr)
            {
                std::string oname = color::white() + toString(lhs->symbol->name) + color::restore();
                parserError(ctx, "reference to member of undefined object '" + oname + "'");
            }
            lhsTypeId = vi->typeId;
        }
        else // Going down a recursive MemberRef chain
        {
            lhsTypeId = g_lastRhsTypeId;
            MOON_ASSERT(lhsTypeId != nullptr);
        }

        // With the type of the left-hand-side object we can figure
        // out the type of the right-hand-side member reference:
        MOON_ASSERT(rhs->symbol != nullptr);
        const auto memberName = rhs->symbol->name;
        const Variant member  = ((lhsTypeId->templateObject != nullptr) ?
                                  lhsTypeId->templateObject->findMemberVar(memberName) :
                                  Variant{});

        if (member.isNull())
        {
            std::string tname = color::white() + toString(lhsTypeId->name) + color::restore();
            std::string mname = color::white() + toString(memberName) + color::restore();
            parserError(ctx, "Type " + tname + " has no member named '" + mname + "'");
        }

        // Fix the member node eval if needed:
        if (rhs->evalType == STEval::Undefined)
        {
            rhs->evalType = varType2Eval(member.type);
        }

        if (member.type == Variant::Type::Object)
        {
            MOON_ASSERT(member.getAsObject() != nullptr);
            g_lastRhsTypeId = member.getAsObject()->getTypeId();
        }
        else
        {
            g_lastRhsTypeId = varType2TypeId(ctx.vm->types, member.type);
        }

        result.type = member.type;
    }
    else
    {
        const Variant::Type lhsVarType = eval2VarType(lhs->evalType);
        const Variant::Type rhsVarType = eval2VarType(rhs->evalType);

        if (binOp == OpCode::StoreGlob) // Generic assignment tag
        {
            if (!isAssignmentValid(lhsVarType, rhsVarType))
            {
                parserError(ctx, "cannot assign " + toString(rhsVarType) + " to " + toString(lhsVarType));
            }
            // Assignments cannot change the left-hand-side type.
            result.type = lhsVarType;
        }
        else // Comparison, sum, division, etc...
        {
            if (!isBinaryOpValid(binOp, lhsVarType, rhsVarType))
            {
                parserError(ctx, "cannot apply operator " + binaryOpToString(binOp) + " on " +
                            toString(lhsVarType) + " and " + toString(rhsVarType));
            }
            // Perform the op on default initialized dummy vars to get the correct resulting type:
            result = performBinaryOp(binOp, Variant{ lhsVarType }, Variant{ rhsVarType });
        }
    }

    return ctx.syntTree->newNode(type, lhs, rhs, nullptr, varType2Eval(result.type));
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newUnaryOpNode(ParseContext & ctx, const STNode type,
                                       const OpCode unaryOp, const SyntaxTreeNode * operand)
{
    const Variant::Type varType = eval2VarType(operand->evalType);
    if (!isUnaryOpValid(unaryOp, varType))
    {
        parserError(ctx, "cannot apply unary operator " + unaryOpToString(unaryOp) + " on type " + toString(varType));
    }

    // Perform the op on a default initialized var to get the correct resulting type:
    const Variant result = performUnaryOp(unaryOp, Variant{ varType });
    return ctx.syntTree->newNode(type, operand, nullptr, nullptr, varType2Eval(result.type));
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newTypecastNode(ParseContext & ctx,
                                        const SyntaxTreeNode * lhs,
                                        const SyntaxTreeNode * rhs)
{
    // It is a syntax error to pass anything else, so an assert suffices.
    MOON_ASSERT(rhs->nodeType == STNode::ExprTypeIdent);

    // Left-hand-side validation:
    if (lhs->evalType == STEval::Undefined)
    {
        std::string name = color::white() + toString(lhs->symbol->name) + color::restore();
        parserError(ctx, "referencing undefined identifier '" + name + "' in cast expression");
    }
    else if (lhs->nodeType != STNode::ExprFuncCall &&
             ctx.vm->functions.findFunction(lhs->symbol->name))
    {
        parserError(ctx, "referencing function name on left-hand side of cast "
                         "expression. Did you mean to call it instead?");
    }
    else if (ctx.vm->types.findTypeId(lhs->symbol->name))
    {
        parserError(ctx, "referencing type name in the wrong side of a cast expression");
    }

    // See if the typecast is possible:
    // We can pretend this is an assignment, so no need to define a new typecast operator for now.
    // Right-hand-side type is the target of our fake assignment.
    if (!isAssignmentValid(eval2VarType(rhs->evalType), eval2VarType(lhs->evalType)))
    {
        std::string srcType = color::white() + toString(eval2TypeId(ctx.vm->types, lhs->evalType)->name) + color::restore();
        std::string dstType = color::white() + toString(eval2TypeId(ctx.vm->types, rhs->evalType)->name) + color::restore();
        parserError(ctx, "cannot cast from " + srcType + " to " + dstType);
    }

    // Optional superfluous cast warning:
    if (lhs->evalType == rhs->evalType)
    {
        std::string tname = color::white() + toString(eval2TypeId(ctx.vm->types, lhs->evalType)->name) + color::restore();
        parserWarn(ctx, "unnecessary typecast from " + tname + " to " + tname);
    }

    return ctx.syntTree->newNode(STNode::ExprTypecast, lhs, rhs, nullptr, rhs->evalType);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newTypeofNode(ParseContext & ctx, SyntaxTreeNode * exprOrTypeNode)
{
    STEval stEval = exprOrTypeNode->evalType;
    if (stEval == STEval::Undefined)
    {
        // Could be a function name of a UDT name.
        MOON_ASSERT(exprOrTypeNode->symbol != nullptr);
        const auto name = exprOrTypeNode->symbol->name;

        if (ctx.vm->functions.findFunction(name))
        {
            stEval = STEval::Func;
        }
        else if (ctx.vm->types.findTypeId(name))
        {
            stEval = STEval::UDT;
        }
        else
        {
            parserError(ctx, "undefined type or expression as type_of() argument");
        }
        exprOrTypeNode->evalType = stEval; // Fix the node.
    }

    return ctx.syntTree->newNode(STNode::ExprTypeof, exprOrTypeNode, nullptr, nullptr, stEval);
}

// ------------------------------------------------------------------

static void collectFunctionArgTypes(ParseContext & ctx, const SyntaxTreeNode * root,
                                    Variant::Type * argTypesOut, UInt32 & argCountOut,
                                    UInt32 & extraFlagsOut)
{
    if (root == nullptr)
    {
        return;
    }
    if (argCountOut == Function::MaxArguments)
    {
        parserError(ctx, "max function argument count (" + toString(Function::MaxArguments) + ") exceeded!");
    }

    const auto argNode = root->getChild(1);
    const auto stEval  = argNode->evalType;

    if (stEval == STEval::VarArgs)
    {
        extraFlagsOut |= Function::VarArgs;
        return;
    }

    argTypesOut[argCountOut++] = eval2VarType(stEval);
    collectFunctionArgTypes(ctx, root->getChild(0), argTypesOut, argCountOut, extraFlagsOut);
}

// ------------------------------------------------------------------

static void collectFunctionCallArgs(ParseContext & ctx, const SyntaxTreeNode * root,
                                    Variant * argVarsOut, UInt32 & argCountOut)
{
    if (root == nullptr)
    {
        return;
    }
    if (argCountOut == Function::MaxArguments)
    {
        parserError(ctx, "max function argument count (" + toString(Function::MaxArguments) + ") exceeded!");
    }

    const auto stEval = root->evalType;
    if (stEval == STEval::Undefined)
    {
        parserError(ctx, "passing undefined variable as argument " + toString(argCountOut + 1) + " of function call");
    }

    argVarsOut[argCountOut++] = Variant{ eval2VarType(stEval) };
    collectFunctionCallArgs(ctx, root->getChild(0), argVarsOut, argCountOut);
}

// ------------------------------------------------------------------

static void collectObjMembers(ParseContext & ctx, const SyntaxTreeNode * root, Object * objOut)
{
    if (root == nullptr)
    {
        return;
    }

    const auto stEval  = root->evalType;
    const auto varName = root->symbol->name;

    if (objOut->hasMember(varName))
    {
        std::string mname = color::white() + toString(varName) + color::restore();
        parserError(ctx, objOut->getTypeName() + " member '" + mname + "' was defined more than once");
    }

    Variant data{ eval2VarType(stEval) };

    // Members that reference other User Defined Types require special handling.
    if (data.type == Variant::Type::Object)
    {
        MOON_ASSERT(root->getChild(1) != nullptr);

        const auto typeName = root->getChildSymbol(1)->name;
        const TypeId * typeId = ctx.vm->types.findTypeId(typeName);

        if (typeId == nullptr)
        {
            std::string tname = color::white() + toString(typeName) + color::restore();
            parserError(ctx, "cannot declare member variable of undefined type '" + tname + "'");
        }

        data.value.asObject = const_cast<Object *>(typeId->templateObject);
    }

    printf("ADDING OBJ MEMBER: %s: %s\n", toString(varName).c_str(), toString(data.type).c_str());
    objOut->addMember(varName, data);
    collectObjMembers(ctx, root->getChild(0), objOut);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newFunctionCallNode(ParseContext & ctx,
                                            const Symbol * funcNameSymbol,
                                            SyntaxTreeNode * argListNode)
{
    MOON_ASSERT(funcNameSymbol != nullptr);

    const auto funcName = funcNameSymbol->name;
    const auto func = ctx.vm->functions.findFunction(funcName);

    if (func == nullptr)
    {
        std::string fname = color::white() + toString(funcName) + color::restore();
        parserError(ctx, "attempting to call undefined function '" + fname + "'");
    }

    // Use the return type of the function for this node's eval type.
    const STEval stEval = func->hasReturnVal() ? varType2Eval(*func->returnType) : STEval::Void;

    // Gather the args passed in (we only care about the types now):
    UInt32 argCount = 0;
    Variant argVars[Function::MaxArguments];
    collectFunctionCallArgs(ctx, argListNode, argVars, argCount);

    // Check them against the expected. We reuse the runtime stack code for that.
    std::string errorMessage;
    const Stack::Slice args{ argVars, static_cast<int>(argCount) };
    if (!func->validateArguments(args, errorMessage))
    {
        parserError(ctx, errorMessage);
    }

    // Check if function call should be stripped on debug builds (becomes a no-op).
    if (!g_debugMode && func->isDebugOnly())
    {
        return ctx.syntTree->newNode(STNode::NoOp, nullptr, nullptr, nullptr, STEval::Void);
    }

    // Functions like assert() and panic() prepend source location to the call.
    if (func->hasCallerInfo())
    {
        const char * srcFileName = (ctx.srcFile       != nullptr) ? ctx.srcFile->c_str()           : "<unknown file>";
        const char * callerName  = (g_currentFunction != nullptr) ? g_currentFunction->name->chars : "<global scope>";

        auto fileNode = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, ctx.symTable->findOrDefineStrValue(srcFileName));
        auto lineNode = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, ctx.symTable->findOrDefineIntValue(ctx.lexer->lineno()));
        auto funcNode = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, ctx.symTable->findOrDefineStrValue(callerName));

        fileNode->evalType = STEval::Str;
        lineNode->evalType = STEval::Long;
        funcNode->evalType = STEval::Str;

        fileNode->setChild(0, lineNode);
        lineNode->setChild(0, funcNode);
        funcNode->setChild(0, argListNode);

        // file, line and function will precede the argument list.
        argListNode = fileNode;
    }

    // First (0) child is reserved for chaining the call itself to another parameter_list.
    // Second (1) child is the parameter_list chain.
    return ctx.syntTree->newNodeWithSymbol(STNode::ExprFuncCall, funcNameSymbol, nullptr, argListNode, nullptr, stEval);
}

// ------------------------------------------------------------------

static void initEnumMembers(ParseContext & ctx, const SyntaxTreeNode * root,
                            Object * objOut, Int64 & nextEnumIntVal)
{
    if (root == nullptr)
    {
        return;
    }

    const auto stEval  = root->evalType;
    const auto varName = root->symbol->name;

    if (objOut->hasMember(varName))
    {
        std::string mname = color::white() + toString(varName) + color::restore();
        parserError(ctx, objOut->getTypeName() + " member '" + mname + "' was defined more than once");
    }

    Variant data{ eval2VarType(stEval) };
    const auto initExprNode = root->getChild(1);

    if (initExprNode != nullptr)
    {
        if (initExprNode->nodeType == STNode::ExprLiteralConst)
        {
            if (initExprNode->evalType == STEval::Int ||
                initExprNode->evalType == STEval::Long)
            {
                MOON_ASSERT(data.type == Variant::Type::Integer);
                data = variantFromSymbol(*ctx.vm, *initExprNode->symbol);
            }
            else // string, float, bool
            {
                const auto initVal = variantFromSymbol(*ctx.vm, *initExprNode->symbol);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
                // Enum strings have program lifetime.
                if (data.type == Variant::Type::Str)
                {
                    data.getAsString()->flags.isPersistent = true;
                }
            }
        }
        else // identifier / other enum member ref
        {
            if (initExprNode->nodeType == STNode::ExprNameIdent)
            {
                const auto initVal = objOut->findMemberVar(initExprNode->symbol->name);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
            }
            else
            {
                MOON_ASSERT(initExprNode->nodeType == STNode::ExprMemberRef);

                // Already checked when parsing, so an assert suffices.
                const auto otherEnum = ctx.vm->types.findTypeId(initExprNode->getChildSymbol(0)->name);
                MOON_ASSERT(otherEnum != nullptr);

                const auto initVal = otherEnum->templateObject->findMemberVar(initExprNode->getChildSymbol(1)->name);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
            }
        }
    }
    else // sequential integer list
    {
        MOON_ASSERT(data.type == Variant::Type::Integer);
        data.value.asInteger = nextEnumIntVal++;
    }

    if (data.type == Variant::Type::Integer)
    {
        nextEnumIntVal = data.value.asInteger + 1;
    }

    printf("ADDING ENUM CONST: %s: %s\n", toString(varName).c_str(), toString(data.type).c_str());
    objOut->addMember(varName, data);
    initEnumMembers(ctx, root->getChild(0), objOut, nextEnumIntVal);
}

// ------------------------------------------------------------------

static STEval enumMemberConstantReference(ParseContext & ctx, SyntaxTreeNode * eTypeNode, SyntaxTreeNode * eConstNode)
{
    MOON_ASSERT(eTypeNode->symbol  != nullptr);
    MOON_ASSERT(eConstNode->symbol != nullptr);

    const auto typeName = eTypeNode->symbol->name;
    const auto enumType = ctx.vm->types.findTypeId(typeName);

    if (enumType == nullptr)
    {
        std::string ename = color::white() + toString(typeName) + color::restore();
        parserError(ctx, "reference to undefined enum type '" + ename + "'");
    }
    MOON_ASSERT(enumType->templateObject != nullptr);

    const auto constName = eConstNode->symbol->name;
    const auto enumConst = enumType->templateObject->findMemberIndex(constName);

    if (enumConst < 0)
    {
        std::string cname = color::white() + toString(typeName) + "." + toString(constName) + color::restore();
        parserError(ctx, "reference to undefined enum constant '" + cname + "'");
    }

    // Okay
    const STEval stEvalConst = varType2Eval(enumType->templateObject->getMemberAt(enumConst).data.type);
    eTypeNode->evalType  = STEval::UDT;
    eConstNode->evalType = stEvalConst;
    return stEvalConst;
}

// ------------------------------------------------------------------

static void checkEnumInitializers(ParseContext & ctx, const SyntaxTreeNode * root,
                                  const SyntaxTreeNode * iterNode, int & numOfNonIntegralConstants)
{
    if (iterNode == nullptr)
    {
        return;
    }

    if (iterNode->evalType == STEval::Undefined)
    {
        // Trying to init the constant with itself?
        if (iterNode->symbol == iterNode->getChildSymbol(1))
        {
            std::string cname = color::white() + toString(iterNode->symbol->name) + color::restore();
            parserError(ctx, "assigning enum constant '" + cname + "' to itself");
        }

        // Reference to a previously defined constant in this enum?
        bool foundIt = false;
        for (auto node = root; node != iterNode; node = node->getChild(0))
        {
            if (node->symbol == iterNode->getChildSymbol(1))
            {
                const_cast<SyntaxTreeNode *>(iterNode)->evalType = node->evalType;
                const_cast<SyntaxTreeNode *>(iterNode->getChild(1))->evalType = node->evalType;
                foundIt = true;
                break;
            }
        }

        if (!foundIt)
        {
            std::string cname = color::white() + toString(iterNode->getChildSymbol(1)->name) + color::restore();
            parserError(ctx, "assigning undefined identifier '" + cname + "' to enum constant");
        }
    }

    // If not explicitly initialized, we assume sequential integer constants.
    // But in that case, previous constants must also be integers.
    if (iterNode->getChild(1) == nullptr)
    {
        if (numOfNonIntegralConstants != 0)
        {
            parserError(ctx, "unable to deduce next constant value for enum with non-integer constants");
        }
    }

    if (iterNode->evalType != STEval::Int &&
        iterNode->evalType != STEval::Long)
    {
        ++numOfNonIntegralConstants;
    }

    checkEnumInitializers(ctx, root, iterNode->getChild(0), numOfNonIntegralConstants);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newArrayTypeNode(ParseContext & ctx, const SyntaxTreeNode * arrayInitializers)
{
    // We can't allow empty [] array initializers because our arrays are not polymorphic.
    // We need at least one initializer to dictate the underlaying type.
    if (arrayInitializers == nullptr)
    {
        parserError(ctx, "empty array literals are not allowed");
    }

    const STEval firstType = arrayInitializers->evalType;

    // All following array elements must match the first type.
    for (auto node = arrayInitializers->getChild(0); node != nullptr; node = node->getChild(0))
    {
        if (node->evalType != firstType)
        {
            parserError(ctx, "array initializers must all be of the same type");
        }
    }

    const auto typeSymbol = ctx.symTable->findSymbol(eval2TypeId(ctx.vm->types, firstType)->name);
    return ctx.syntTree->newNodeWithEval(STNode::ExprTypeIdent, typeSymbol, firstType);
}

// ------------------------------------------------------------------

static SyntaxTreeNode * newArraySubscriptNode(ParseContext & ctx,
                                              const SyntaxTreeNode * arrayExpr,
                                              const SyntaxTreeNode * indexExpr)
{
    // Multi-dimensional array subscripting or reference to member array
    if (arrayExpr->nodeType == STNode::ExprArraySubscript ||
        arrayExpr->nodeType == STNode::ExprMemberRef)
    {
        // NOTE that we hardcode eval to 'Any'. See the comment below
        // on the ExprFuncCall case for the explanation. This is a current
        // limitation of our implementation and should be improved in the future.
        return ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, arrayExpr, indexExpr, STEval::Any);
    }

    // 1D array subscripting, possibly from the return value of a function:
    MOON_ASSERT(arrayExpr->symbol != nullptr);
    if (arrayExpr->evalType != STEval::Array)
    {
        const std::string name = color::white() + toString(arrayExpr->symbol->name) + color::restore();
        if (arrayExpr->nodeType == STNode::ExprFuncCall)
        {
            parserError(ctx, "function '" + name + "' does not return an array");
        }
        else
        {
            parserError(ctx, "'" + name + "' is not an array ");
        }
    }

    if (indexExpr->evalType != STEval::Int &&
        indexExpr->evalType != STEval::Long)
    {
        parserError(ctx, "array subscript index must be an integer type");
    }

    STEval subscriptEval;
    if (arrayExpr->nodeType == STNode::ExprFuncCall) // Function that returns Array?
    {
        // NOTE:
        // No simple way of figuring out the underlaying type of the
        // array returned by a function/member-ref/multi-dim-array, so
        // in this case we pretend the array type is 'Any' and delegate
        // type-checking to runtime. If there's a type mismatch, it won't
        // show up during compilation, but it will trigger a runtime error.
        // This should be fixed in a future, more robust, implementation.
        subscriptEval = STEval::Any;
    }
    else
    {
        const VarInfo * vi = isParsingFunction() ? findFunctionLocalVar(arrayExpr->symbol) : findGlobalVar(arrayExpr->symbol);
        if (vi == nullptr)
        {
            std::string name = color::white() + toString(arrayExpr->symbol->name) + color::restore();
            parserError(ctx, "reference to undefined variable '" + name + "'");
        }
        MOON_ASSERT(vi->arrayEval != STEval::Undefined);
        MOON_ASSERT(vi->varType == Variant::Type::Array);
        subscriptEval = vi->arrayEval;
    }

    return ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, arrayExpr, indexExpr, subscriptEval);
}

// ------------------------------------------------------------------

int yylex(SemanticVal * yylval, ParseContext & ctx)
{
    ctx.yylval = yylval;
    return ctx.lexer->yylex();
}

void Parser::error(const std::string & message)
{
    parserError(ctx, message);
}

} /* namespace moon */
} /* %code */

/* +-------------------------------------------------+ *
 * | Tokens read by the Lexer (terminal symbols):    | *
 * +-------------------------------------------------+ */

/*
 * In the rules below, we can either use the token id
 * (e.g. OP_ASSIGN) or its string alias (e.g. "=").
 * The string alias is also used to print the token
 * on error messages generated by Bison.
 */

/* Operators: arithmetical/assigment/unary */
%token OP_ASSIGN                  "="
%token OP_PLUS                    "+"
%token OP_MINUS                   "-"
%token OP_MULTIPLY                "*"
%token OP_DIVIDE                  "/"
%token OP_MODULO                  "%"
%token OP_PLUS_ASSIGN             "+="
%token OP_MINUS_ASSIGN            "-="
%token OP_MULTIPLY_ASSIGN         "*="
%token OP_DIVIDE_ASSIGN           "/="
%token OP_MODULO_ASSIGN           "%="

/* Operators: comparisson */
%token OP_CMP_GREATER_THAN        ">"
%token OP_CMP_LESS_THAN           "<"
%token OP_CMP_GREATER_EQUAL       ">="
%token OP_CMP_LESS_EQUAL          "<="
%token OP_CMP_EQUAL               "=="
%token OP_CMP_NOT_EQUAL           "!="

/* Operators: logical/boolean */
%token OP_LOGIC_AND               "and"
%token OP_LOGIC_OR                "or"
%token OP_LOGIC_NOT               "not"

/* Built-in type ids: */
%token TID_INT                    "int"
%token TID_LONG                   "long"
%token TID_FLT                    "float"
%token TID_DBL                    "double"
%token TID_BOOL                   "bool"
%token TID_STR                    "str"
%token TID_ARRAY                  "array"
%token TID_RANGE                  "range"
%token TID_ANY                    "any"
%token TID_TYPEID                 "tid"
%token TID_FUNC                   "function"

/* Language keywords: */
%token KW_IF                      "if"
%token KW_THEN                    "then"
%token KW_ELSE                    "else"
%token KW_ELSEIF                  "elseif"
%token KW_END                     "end"
%token KW_RETURN                  "return"
%token KW_LET                     "let"
%token KW_FUNC                    "func"
%token KW_MATCH                   "match"
%token KW_WITH                    "with"
%token KW_CASE                    "case"
%token KW_DEFAULT                 "default"
%token KW_IN                      "in"
%token KW_DO                      "do"
%token KW_FOR                     "for"
%token KW_WHILE                   "while"
%token KW_LOOP                    "loop"
%token KW_BREAK                   "break"
%token KW_CONTINUE                "continue"
%token KW_TYPE                    "type"
%token KW_ENUM                    "enum"
%token KW_STRUCT                  "struct"
%token KW_TYPEOF                  "type_of"
%token KW_AS                      "as"
%token KW_NULL                    "null"

/* Literal constants: */
%token <asSymbol> INT_LITERAL     "literal integer constant"
%token <asSymbol> FLT_LITERAL     "literal floating-point constant"
%token <asSymbol> BOOL_LITERAL    "literal boolean constant"
%token <asSymbol> STR_LITERAL     "literal string constant"

/* Miscellaneous: */
%token            MEMBER_REF      "."
%token            OPEN_PAR        "("
%token            CLOSE_PAR       ")"
%token            OPEN_CBRAC      "{"
%token            CLOSE_CBRAC     "}"
%token            OPEN_BRAC       "["
%token            CLOSE_BRAC      "]"
%token            COMMA           ","
%token            SEMICOLON       ";"
%token            COLON           ":"
%token            RANGE           ".."
%token            VARARGS         "..."
%token            ARROW           "->"
%token <asSymbol> IDENTIFIER      "identifier"
%token            END_OF_FILE  0  "end of file"

/* +-------------------------------------------------+ *
 * | Operator associativity & rule semantic types:   | *
 * +-------------------------------------------------+ */

/*
 * Operator associativity: LEFT or RIGHT.
 * NOTES:
 * - Using associativity equivalent to the C language.
 * - Order of this list matters! Lower on page, higher precedence.
 * - These should match the order in the 'expression' rule below.
 */
%right OP_MODULO_ASSIGN
%right OP_DIVIDE_ASSIGN
%right OP_MULTIPLY_ASSIGN
%right OP_MINUS_ASSIGN
%right OP_PLUS_ASSIGN
%right OP_ASSIGN
%left  OP_LOGIC_OR
%left  OP_LOGIC_AND
%left  OP_CMP_NOT_EQUAL
%left  OP_CMP_EQUAL
%left  OP_CMP_GREATER_EQUAL
%left  OP_CMP_GREATER_THAN
%left  OP_CMP_LESS_EQUAL
%left  OP_CMP_LESS_THAN
%left  OP_MINUS
%left  OP_PLUS
%left  OP_MODULO
%left  OP_DIVIDE
%left  OP_MULTIPLY
%right OP_LOGIC_NOT
%right UNARY_MINUS /* Context depended fix for unary +,- */
%right UNARY_PLUS  /* See: https://www.gnu.org/software/bison/manual/html_node/Contextual-Precedence.html */
%left  KW_AS       /* Typecast operator (foo as bar) */
%left  OPEN_BRAC   /* Precedence added for the array subscript expression (foo[N]) */
%left  CLOSE_BRAC  /* Array subscript/access precedence */
%left  MEMBER_REF  /* Member access with the dot operator (foo.bar) */

/*
 * Types referenced inside the rules by the '$' signs.
 * E.g.: if you reference a '$' in rule 'type_identifier'
 * it will be a variable of type 'SyntaxTreeNode', as defined
 * in the SemanticVal/YYSTYPE union by the 'asSTNode' field.
 */
%type <asSTNode> type_identifier builtin_type optional_return_type
%type <asSTNode> literal_const_expression identifier_expression
%type <asSTNode> expression array_expression array_subscript_expression object_constructor_expression
%type <asSTNode> translation_unit statement optional_statement_list
%type <asSTNode> for_statement while_statement loop_statement break_statement continue_statement
%type <asSTNode> if_statement elseif_statement else_statement elseif_or_else_or_end
%type <asSTNode> enum_declaration enum_constant enum_constant_list
%type <asSTNode> struct_declaration struct_member_list
%type <asSTNode> func_call_expression func_declaration func_parameter_list_declaration parameter_list return_statement
%type <asSTNode> match_statement match_case match_default match_case_list match_param match_case_param
%type <asSTNode> range_expression range_param range_or_array_or_ident_or_call
%type <asSTNode> let_var_declaration typed_var_declaration
%type <asSTNode> type_alias_declaration expression_or_type_identifier
%type <asSTNode> typeof_expression typecast_expression member_ref_expression

/*
 * Rule the parser starts from. If not explicitly stated,
 * it uses the first nonterminal rule in the below grammar.
 */
%start translation_unit

/* +-------------------------------------------------+ *
 * | Yacc/Bison grammar rules:                       | *
 * +-------------------------------------------------+ */

/* ---- A couple definitions: ----

 * From the Bison manual:
   Each kind of syntactic unit or grouping is named by a 'symbol'. Those which are built by grouping
   smaller constructs according to grammatical rules are called nonterminal symbols; those which can't
   be subdivided are called terminal symbols or token types. We call a piece of input corresponding to
   a single terminal symbol a token, and a piece corresponding to a single nonterminal symbol a grouping.
   We can use the C language as an example of what symbols, terminal and nonterminal, mean.
   The tokens of C are identifiers, constants (numeric and string), and the various keywords,
   arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include
   `identifier`, `number`, `string`, plus one symbol for each keyword, operator or punctuation mark:
   `if`, `return`, `const`, `static`, `int`, `char`, `plus-sign`, `open-brace`, `close-brace`, etc...

 * A 'Shift' step advances in the input stream by one symbol.
   That shifted symbol becomes a new single-node parse tree.

 * A 'Reduce' step applies a completed grammar rule to some of the recent parse trees,
   joining them together as one tree with a new root symbol.

 * Statements:
   Statements do Something and are often composed of expressions (or other statements).
   Statements are everything that can make up a line. E.g.: if/while, return, function declaration, ...

 * Expressions:
   Expressions produce at least one value. Expressions only contain identifiers,
   literals and operators, where operators include arithmetic and boolean operators,
   the function call operator () the subscription operator [] and similar, and can
   be reduced to some kind of "value" or terminal symbol.

--------------------------------- */

%%

/*
 * NOTE: Rules that don't explicitly set $$ are
 * just returning the value of the first element.
 * i.e., it is the same as $$ = $1;
 */

/*---------------------------------------------------.
| Miscellaneous statements, literals, built-in types |
`---------------------------------------------------*/

/* Starting rule */
translation_unit
    : optional_statement_list
        {
            auto treeRoot = ctx.syntTree->newNode(STNode::TranslationUnit, $1, nullptr, nullptr, STEval::Void);
            ctx.syntTree->setRoot(treeRoot);
        }
    ;

/* Zero or more statements allowed */
optional_statement_list
    : optional_statement_list statement
        {
            $$ = ctx.syntTree->newNode(STNode::Statement, $1, $2, nullptr, STEval::Void);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

statement
    : struct_declaration
    | enum_declaration
    | type_alias_declaration
    | func_declaration
    | let_var_declaration
    | if_statement
    | loop_statement
    | while_statement
    | for_statement
    | match_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression ";"
    ;

optional_semicolon
    : ";"
    | %empty
    ;

end_statement
    : "end" optional_semicolon
    ;

literal_const_expression
    : INT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Long,   $1);    }
    | FLT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Double, $1);    }
    | BOOL_LITERAL { $$ = newLiteralNode(ctx, STEval::Bool,   $1);    }
    | STR_LITERAL  { $$ = newLiteralNode(ctx, STEval::Str,    $1);    }
    | KW_NULL      { $$ = newLiteralNode(ctx, STEval::Null, nullptr); }
    ;

builtin_type
    : TID_INT    { $$ = newTypeIdNode(ctx, STEval::Int);    }
    | TID_LONG   { $$ = newTypeIdNode(ctx, STEval::Long);   }
    | TID_FLT    { $$ = newTypeIdNode(ctx, STEval::Float);  }
    | TID_DBL    { $$ = newTypeIdNode(ctx, STEval::Double); }
    | TID_BOOL   { $$ = newTypeIdNode(ctx, STEval::Bool);   }
    | TID_STR    { $$ = newTypeIdNode(ctx, STEval::Str);    }
    | TID_ARRAY  { $$ = newTypeIdNode(ctx, STEval::Array);  }
    | TID_RANGE  { $$ = newTypeIdNode(ctx, STEval::Range);  }
    | TID_ANY    { $$ = newTypeIdNode(ctx, STEval::Any);    }
    | TID_TYPEID { $$ = newTypeIdNode(ctx, STEval::Tid);    }
    | TID_FUNC   { $$ = newTypeIdNode(ctx, STEval::Func);   }
    ;

type_identifier
    : builtin_type
    | IDENTIFIER
        {
            if (!ctx.vm->types.findTypeId($1->name))
            {
                const std::string tname = color::white() + toString($1->name) + color::restore();
                if (ctx.vm->functions.findFunction($1->name))
                {
                    parserError(ctx, "expected type identifier, not function '" + tname + "'");
                }
                else
                {
                    parserError(ctx, "referencing undefined type identifier '" + tname + "'");
                }
            }
            $$ = newTypeIdNode(ctx, STEval::UDT, $1);
        }
    ;

identifier_expression
    : IDENTIFIER
        {
            auto identNode = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1);
            if (!isParsingUDT())
            {
                // Try figuring out the type of this identifier reference
                const VarInfo * vi = isParsingFunction() ? findFunctionLocalVar($1) : findGlobalVar($1);
                if (vi != nullptr)
                {
                    identNode->evalType = vi->stEval;
                }
                else // Could be a function (in a 'var = function' kind of expression)
                {
                    if (ctx.vm->functions.findFunction($1->name))
                    {
                        identNode->evalType = STEval::Func;
                    }
                }
                // Leave undefined. Will trigger an error later.
            }
            $$ = identNode;
        }
    ;

/*------------------------.
| First-class expressions |
`------------------------*/

/*
 * Notes on the 'expression' rule:
 * Operator precedence is determined by the line ordering of the following declarations;
 * the higher the line number of the declaration (lower on the page), higher the precedence.
 *
 * Operator precedence for Moon Lang follows the same precedences of C.
 * https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
 */
expression
    : identifier_expression
    | literal_const_expression
    | array_expression
    | range_expression
    | object_constructor_expression
    | expression[L] "%="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModAssign,       $L, $R); }
    | expression[L] "/="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivAssign,       $L, $R); }
    | expression[L] "*="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMulAssign,       $L, $R); }
    | expression[L] "-="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubAssign,       $L, $R); }
    | expression[L] "+="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAddAssign,       $L, $R); }
    | expression[L] "="   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAssign,          $L, $R); }
    | expression[L] "or"  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicOr,         $L, $R); }
    | expression[L] "and" expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicAnd,        $L, $R); }
    | expression[L] "!="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpNotEqual,     $L, $R); }
    | expression[L] "=="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpEqual,        $L, $R); }
    | expression[L] ">="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterEqual, $L, $R); }
    | expression[L] ">"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterThan,  $L, $R); }
    | expression[L] "<="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessEqual,    $L, $R); }
    | expression[L] "<"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessThan,     $L, $R); }
    | expression[L] "-"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubtract,        $L, $R); }
    | expression[L] "+"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAdd,             $L, $R); }
    | expression[L] "%"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModulo,          $L, $R); }
    | expression[L] "/"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivide,          $L, $R); }
    | expression[L] "*"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMultiply,        $L, $R); }
    | "not" expression[R]                   { $$ = newUnaryOpNode(ctx, STNode::ExprLogicNot,   OpCode::LogicNot, $R); }
    | "-"   expression[R] %prec UNARY_MINUS { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryMinus, OpCode::Negate,   $R); }
    | "+"   expression[R] %prec UNARY_PLUS  { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryPlus,  OpCode::Plus,     $R); }
    | typecast_expression
    | typeof_expression
    | array_subscript_expression
    | func_call_expression
    | member_ref_expression
    | "(" expression ")"
        {
            // Wrapping an expr in ( ) gives it the highest precedence.
            // So just reapply the rule with the new precedence.
            $$ = $2;
        }
    ;

expression_or_type_identifier
    : expression   /* expression already incorporates identifier_expression */
    | builtin_type /* so all we need to add are the built-in types */
    ;

typeof_expression
    : KW_TYPEOF "(" expression_or_type_identifier ")"
        {
            $$ = newTypeofNode(ctx, $3);
        }
    ;

typecast_expression
    : expression[L] "as" type_identifier[R]
        {
            $$ = newTypecastNode(ctx, $L, $R);
        }
    ;

member_ref_expression
    : expression[L] "." expression[R]
        {
            $$ = newBinaryOpNode(ctx, STNode::ExprMemberRef, $L, $R);
        }
    ;

/*------------------------------.
| Parameter lists and functions |
`------------------------------*/

/* Shared by constructors, function calls and array literals */
parameter_list
    : expression
    | expression "," parameter_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_parameter_list_declaration
    : typed_var_declaration
    | typed_var_declaration "," func_parameter_list_declaration
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | IDENTIFIER "..."
        {
            // Note: In a VarArgs function, the varargs node will be at child 1.
            // This is to facilitate the traversal in collectFunctionArgTypes().
            auto varArgsNode = newTypeIdNode(ctx, STEval::VarArgs);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $1,
                        nullptr, varArgsNode, nullptr, varArgsNode->evalType);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_call_expression
    : IDENTIFIER "(" parameter_list ")"
        {
            $$ = newFunctionCallNode(ctx, $1, $3);
        }
    ;

func_declaration
    : "func" IDENTIFIER { beginFunc(ctx, $2); } "(" func_parameter_list_declaration ")" optional_return_type
    { g_expectedReturnType = $7->evalType; } optional_statement_list end_statement
        {
            // child[0] = parameter list
            // child[1] = function body
            // child[2] = return type
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::FuncDeclStatement, $2, $5, $9, $7, $7->evalType);

            // Redefinition not allowed. We also don't currently support function overloads.
            const auto funcName = $2->name;
            if (ctx.vm->functions.findFunction(funcName))
            {
                std::string fname = color::white() + toString(funcName) + color::restore();
                parserError(ctx, "function '" + fname + "' was defined more than once");
            }

            UInt32 extraFlags = 0;
            UInt32 argCount   = 0;
            Variant::Type argTypes[Function::MaxArguments];

            // nullptr indicates no return type (void).
            const Variant::Type * pRetType = nullptr;
            Variant::Type retTypeTemp;

            if ($7->evalType != STEval::Void)
            {
                retTypeTemp = eval2VarType($7->evalType);
                pRetType = &retTypeTemp;
            }

            collectFunctionArgTypes(ctx, $5, argTypes, argCount, extraFlags);
            if (extraFlags & Function::VarArgs)
            {
                argCount = 0;
            }

            // Register the new function:
            ctx.vm->functions.addFunction(funcName, pRetType, (argCount != 0) ? argTypes : nullptr,
                                          argCount, 0, extraFlags, nullptr);
            endFunc(ctx);
        }
    ;

/* A function declaration can either have an explicit return type or implicit void return */
optional_return_type
    : "->" type_identifier
        {
            $$ = $2;
        }
    | %empty
        {
            $$ = newTypeIdNode(ctx, STEval::Void);
        }
    ;

/*-----------------------------------.
| Array literals and array subscript |
`-----------------------------------*/

array_expression
    : "[" parameter_list "]"
        {
            // First child reserved for parameter_list chains
            // Third child has the type of the array storage
            $$ = ctx.syntTree->newNode(STNode::ExprArrayLiteral, nullptr, $2, newArrayTypeNode(ctx, $2), STEval::Array);
        }
    ;

array_subscript_expression
    : expression "[" expression "]"
        {
            $$ = newArraySubscriptNode(ctx, $1, $3);
        }
    ;

/*------------------------.
| Object constructor call |
`------------------------*/

object_constructor_expression
    : type_identifier "{" parameter_list "}"
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprObjectConstructor, $1->symbol,
                                                            nullptr, $3, $1, $1->evalType);
        }
    ;

/*-----------------.
| Var declarations |
`-----------------*/

/* NOTE: The type node will always be the second child (child[1]), if present */
typed_var_declaration
    : IDENTIFIER ":" type_identifier
        {
            $$ = newVarDeclNode(ctx, $1, nullptr, $3, $3->evalType);
        }
    ;

/* NOTE: The type node will always be the second child (child[1]), if present */
let_var_declaration
    : "let" IDENTIFIER ":" type_identifier "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $6, $4, $4->evalType);
        }
    | "let" IDENTIFIER ":" type_identifier ";"
        {
            $$ = newVarDeclNode(ctx, $2, nullptr, $4, $4->evalType);
        }
    | "let" IDENTIFIER "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $4, nullptr, $4->evalType);
        }
    ;

/*----------------------------.
| If, else, elseif statements |
`----------------------------*/

if_statement
    : "if" expression "then" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenStatement, $2, $4, nullptr);
        }
    | "if" expression "then" optional_statement_list else_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseStatement, $2, $4, $5);
        }
    | "if" expression "then" optional_statement_list elseif_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

elseif_statement
    : "elseif" expression "then" optional_statement_list elseif_or_else_or_end
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

else_statement
    : "else" optional_statement_list end_statement { $$ = $2; }
    ;

elseif_or_else_or_end
    : elseif_statement
    | else_statement
    | end_statement { $$ = nullptr; }
    ;

/*--------------------------.
| Loops and jump statements |
`--------------------------*/

return_statement
    : "return" ";"
        {
            if (!isParsingFunction())
            {
                parserError(ctx, "return statement found outside of a function");
            }
            else if (g_expectedReturnType != STEval::Void)
            {
                parserError(ctx, "function '" + toString(g_currentFunction->name) +
                                 "' was expected to return " + toString(eval2VarType(g_expectedReturnType)));
            }
            else
            {
                $$ = ctx.syntTree->newNode(STNode::ReturnStatement, nullptr, nullptr, nullptr, STEval::Void);
            }
        }
    | "return" expression ";"
        {
            const auto exprNode = $2;
            if (!isParsingFunction())
            {
                parserError(ctx, "return statement found outside of a function");
            }
            else if ((exprNode->symbol   != nullptr) &&
                     (exprNode->nodeType != STNode::ExprFuncCall) &&
                     (exprNode->nodeType != STNode::ExprLiteralConst) &&
                     !findFunctionLocalVar(exprNode->symbol) && !findGlobalVar(exprNode->symbol))
            {
                parserError(ctx, "undefined return expression '" + toString(exprNode->symbol->name) + "'");
            }
            else if (g_expectedReturnType == STEval::Void)
            {
                parserError(ctx, "void function '" + toString(g_currentFunction->name) + "' is not supposed to return a value");
            }
            else if (!isAssignmentValid(eval2VarType(g_expectedReturnType), eval2VarType(exprNode->evalType)))
            {
                parserError(ctx, "function '" + toString(g_currentFunction->name) +
                                 "' was expected to return " + toString(eval2VarType(g_expectedReturnType)));
            }
            else
            {
                $$ = ctx.syntTree->newNode(STNode::ReturnStatement, exprNode, nullptr, nullptr, exprNode->evalType);
            }
        }
    ;

break_statement
    : "break" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::BreakStatement);
        }
    ;

continue_statement
    : "continue" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ContinueStatement);
        }
    ;

loop_statement
    : "loop" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::LoopStatement, $2);
        }
    ;

while_statement
    : "while" expression "do" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::WhileStatement, $2, $4, nullptr);
        }
    ;

for_statement
    : "for" IDENTIFIER "in" range_or_array_or_ident_or_call "do" optional_statement_list end_statement
        {
            // loopVarNode type has to be inferred from the loop expression/range
            auto loopVarNode = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $2);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ForStatement, nullptr, loopVarNode, $4, $6);
        }
    ;

/*-----------------------.
| Match switch statement |
`-----------------------*/

/* Things allowed on a 'match X with' statement: */
match_param
    : literal_const_expression
    | identifier_expression
    | array_subscript_expression
    | func_call_expression
    ;

/* Things that can appear as the argument of a 'case' statement: */
match_case_param
    : literal_const_expression
    | range_or_array_or_ident_or_call
    ;

match_statement
    : "match" match_param "with" match_case_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchStatement, $2, $4);
        }
    ;

match_default
    : "default" "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchDefaultStatement, nullptr, $3);
        }
    ;

match_case
    : "case" match_case_param "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchCaseStatement, $2, $4);
        }
    ;

match_case_list
    : match_case match_case_list
        {
            $$ = $1;
            $$->setChild(2, $2);
        }
    | match_default
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*------------------.
| Range expressions |
`------------------*/

range_or_array_or_ident_or_call
    : range_expression
    | array_expression
    | array_subscript_expression
    | func_call_expression
    | identifier_expression
    ;

range_expression
    : range_param ".." range_param
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNode(STNode::ExprRange, nullptr, $1, $3, STEval::Range);
        }
    ;

/*
 * Possible elements for a range parameter:
 * variables/identifiers:         x .. y
 * function return val:           0 .. len()
 * integer literals:              0 .. 10
 * strings (OK for single char):  "a" .. "z"
 */
range_param
    : func_call_expression
    | identifier_expression
    | INT_LITERAL
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, $1,
                                 nullptr, nullptr, nullptr, symbol2Eval(*$1));
        }
    | STR_LITERAL
        {
            const auto symbol = $1;
            if (symbol->value.asString->length != 1)
            {
                parserError(ctx, "only single character literals are allowed in range expressions");
            }
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, symbol,
                                 nullptr, nullptr, nullptr, symbol2Eval(*symbol));
        }
    ;

/*-----------------.
| Enum declaration |
`-----------------*/

enum_declaration
    : "type" IDENTIFIER "enum" { beginUDT(ctx, $2, "enum"); } enum_constant_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::EnumDeclStatement, $2,
                                            $5, nullptr, nullptr, STEval::UDT);

            // Redefinition not allowed.
            const auto typeName = $2->name;
            if (ctx.vm->types.findTypeId(typeName))
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "enum '" + tname + "' was defined more than once");
            }

            Object * templateObj = Enum::newInstance(*ctx.vm, nullptr);
            auto newTypeId = ctx.vm->types.addTypeId(typeName, &Enum::newInstance, templateObj, false);
            templateObj->setTypeId(newTypeId);
            templateObj->markTypeTemplate();

            // This will search for undefined STEvals in the initializers and update
            // them if the enum const references a global constant or a previously
            // defined sibling constant in this enum. It also checks that uninitialized
            // constant are not used on an enum with non-integral values.
            int numOfNonIntegralConstants = 0;
            checkEnumInitializers(ctx, $5, $5, numOfNonIntegralConstants);

            Int64 nextEnumIntVal = 0;
            initEnumMembers(ctx, $5, templateObj, nextEnumIntVal);
            endUDT(ctx);
        }
    ;

enum_constant
    : IDENTIFIER
        { // Uninitialized enum constant
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                  nullptr, nullptr, nullptr, STEval::Long);
        }
    | IDENTIFIER "=" literal_const_expression
        { // Constant initialized from compile-time literal value
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression
        { // Constant with explicit initializer (a prev constant from this enum)
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression "." identifier_expression
        { // Constant initialized from a reference to a member constant of another enum
            const auto stEval = enumMemberConstantReference(ctx, $3, $5);
            auto initExpr = newBinaryOpNode(ctx, STNode::ExprMemberRef, $3, $5);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, initExpr, nullptr, stEval);
        }
    ;

enum_constant_list
    : enum_constant
    | enum_constant "," enum_constant_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*--------------------------------.
| Structured types and type alias |
`--------------------------------*/

type_alias_declaration
    : "type" IDENTIFIER "=" type_identifier { requireGlobalScope(ctx, "type alias"); } ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::TypeAliasDeclStatement, $2,
                                                 $4, nullptr, nullptr, STEval::UDT);

            const auto aliasName = $2->name;
            const auto typeName  = $4->symbol->name;

            // Redefinition not allowed.
            if (ctx.vm->types.findTypeId(aliasName))
            {
                std::string tname = color::white() + toString(aliasName) + color::restore();
                parserError(ctx, "type alias '" + tname + "' was defined more than once");
            }

            // New definition:
            const auto existingType = ctx.vm->types.findTypeId(typeName);
            if (existingType == nullptr)
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "trying to alias undefined type '" + tname + "'");
            }

            ctx.vm->types.addTypeAlias(existingType, aliasName);
        }
    ;

struct_declaration
    : "type" IDENTIFIER "struct" { beginUDT(ctx, $2, "struct"); } struct_member_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::StructDeclStatement, $2,
                                              $5, nullptr, nullptr, STEval::UDT);

            // Redefinition not allowed.
            const auto typeName = $2->name;
            if (ctx.vm->types.findTypeId(typeName))
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "struct '" + tname + "' was defined more than once");
            }

            Object * templateObj = Struct::newInstance(*ctx.vm, nullptr);
            auto newTypeId = ctx.vm->types.addTypeId(typeName, &Struct::newInstance, templateObj, false);
            templateObj->setTypeId(newTypeId);
            templateObj->markTypeTemplate();

            collectObjMembers(ctx, $5, templateObj);
            endUDT(ctx);
        }
    ;

struct_member_list
    : typed_var_declaration
    | typed_var_declaration "," struct_member_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

%%
