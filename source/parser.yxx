
/* +-------------------------------------------------+ *
 * | Bison configuration parameters:                 | *
 * +-------------------------------------------------+ */

/* https://www.gnu.org/software/bison/manual/html_node/index.html */
%require  "3.0.4"
%skeleton "lalr1.cc"
%defines

%define parse.assert true
%define parse.error  verbose

%define api.namespace     {moon}
%define parser_class_name {Parser}

%parse-param {ParseContext & ctx}
%lex-param   {ParseContext & ctx}

%{
/*
 * Nothing to be added in the prologue section at the moment.
 * Left it here because Vim's syntax highlighting gets messed
 * up if this section is missing.
 *
 * Most of the stuff depends on the header file, so they
 * must be placed inside the %code { } section.
 */
%}

/* +-------------------------------------------------+ *
 * | Additional verbatin code sections:              | *
 * +-------------------------------------------------+ */

/* 'Requires' section is added to generated parser header file.
 * Good place for forwad declaration and types used in the yylval union. */
%code requires
{
    #define INC_PARSER 1
    #include "common.hpp"
    #undef  INC_PARSER

    #include "symbol_table.hpp"
    #include "syntax_tree.hpp"
}

/* The unqualified code section is added to the implementation file, after
 * the parser header is included, which is the right place for these. */
%code
{
    /* Shorthand aliases: */
    using AstNode = moon::SyntaxTreeNode::Type;
    using AstEval = moon::SyntaxTreeNode::Eval;

    static moon::SyntaxTreeNode * newTypeIdNode(moon::ParseContext & ctx, const AstEval tid,
                                                const moon::Symbol * symbol = nullptr)
    {
        if (symbol == nullptr)
        {
            symbol = moon::symbolFromEval(*ctx.symTable, tid);
        }
        return ctx.syntTree->newNodeWithEval(AstNode::ExprTypeIdent, symbol, tid);
    }

    static moon::SyntaxTreeNode * newLiteralNode(moon::ParseContext & ctx, const AstEval tid,
                                                 const moon::Symbol * symbol)
    {
        return ctx.syntTree->newNodeWithEval(AstNode::ExprLiteralConst, symbol, tid);
    }
}

/* +-------------------------------------------------+ *
 * | Tokens read by the Lexer (terminal symbols):    | *
 * +-------------------------------------------------+ */

/*
 * In the rules below, we can either use the token id
 * (e.g. OP_ASSIGN) or its string alias (e.g. "=").
 * The string alias is also used to print the token
 * on error messages generated by Bison.
 */

/* Operators: arithmetical/assigment/unary */
%token OP_ASSIGN                  "="
%token OP_PLUS                    "+"
%token OP_MINUS                   "-"
%token OP_MULTIPLY                "*"
%token OP_DIVIDE                  "/"
%token OP_MODULO                  "%"
%token OP_PLUS_EQUAL              "+="
%token OP_MINUS_EQUAL             "-="
%token OP_MULTIPLY_EQUAL          "*="
%token OP_DIVIDE_EQUAL            "/="
%token OP_MODULO_EQUAL            "%="

/* Operators: comparisson */
%token OP_CMP_GREATER_THAN        ">"
%token OP_CMP_LESS_THAN           "<"
%token OP_CMP_GREATER_EQUAL       ">="
%token OP_CMP_LESS_EQUAL          "<="
%token OP_CMP_EQUAL               "=="
%token OP_CMP_NOT_EQUAL           "!="

/* Operators: logical/boolean */
%token OP_LOGIC_AND               "and"
%token OP_LOGIC_OR                "or"
%token OP_LOGIC_NOT               "not"

/* Built-in type ids: */
%token TID_INT                    "int"
%token TID_LONG                   "long"
%token TID_FLT                    "float"
%token TID_BOOL                   "bool"
%token TID_STR                    "string"
%token TID_ARRAY                  "array"
%token TID_RANGE                  "range"
%token TID_ANY                    "any"

/* Language keywords: */
%token KW_IF                      "if"
%token KW_THEN                    "then"
%token KW_ELSE                    "else"
%token KW_ELSEIF                  "elseif"
%token KW_END                     "end"
%token KW_RETURN                  "return"
%token KW_LET                     "let"
%token KW_FUNC                    "func"
%token KW_MATCH                   "match"
%token KW_WITH                    "with"
%token KW_CASE                    "case"
%token KW_DEFAULT                 "default"
%token KW_IN                      "in"
%token KW_DO                      "do"
%token KW_FOR                     "for"
%token KW_WHILE                   "while"
%token KW_LOOP                    "loop"
%token KW_BREAK                   "break"
%token KW_CONTINUE                "continue"
%token KW_TYPE                    "type"
%token KW_ENUM                    "enum"
%token KW_STRUCT                  "struct"
%token KW_MODULE                  "module"

/* Literal constants: */
%token <asSymbol> INT_LITERAL     "literal integer constant"
%token <asSymbol> FLT_LITERAL     "literal floating-point constant"
%token <asSymbol> BOOL_LITERAL    "literal boolean constant"
%token <asSymbol> STR_LITERAL     "literal string constant"

/* Miscellaneous: */
%token            OPEN_PAR        "("
%token            CLOSE_PAR       ")"
%token            OPEN_CBRAC      "{"
%token            CLOSE_CBRAC     "}"
%token            OPEN_BRAC       "["
%token            CLOSE_BRAC      "]"
%token            COMMA           ","
%token            SEMICOLON       ";"
%token            COLON           ":"
%token            RANGE           ".."
%token            VARARGS         "..."
%token            ARROW           "->"
%token <asSymbol> IDENTIFIER      "identifier"
%token            END_OF_FILE  0  "end of file"

/* +-------------------------------------------------+ *
 * | Operator associativity & rule semantic types:   | *
 * +-------------------------------------------------+ */

/*
 * Operator associativity: LEFT or RIGHT.
 * NOTE: Using same associativity as the C language.
 */

%right OP_MODULO_EQUAL
%right OP_DIVIDE_EQUAL
%right OP_MULTIPLY_EQUAL
%right OP_MINUS_EQUAL
%right OP_PLUS_EQUAL
%right OP_ASSIGN
%right OP_LOGIC_NOT
%left  OP_LOGIC_OR
%left  OP_LOGIC_AND
%left  OP_CMP_NOT_EQUAL
%left  OP_CMP_EQUAL
%left  OP_CMP_GREATER_EQUAL
%left  OP_CMP_GREATER_THAN
%left  OP_CMP_LESS_EQUAL
%left  OP_CMP_LESS_THAN
%left  OP_MINUS
%left  OP_PLUS
%left  OP_MODULO
%left  OP_DIVIDE
%left  OP_MULTIPLY

/*
 * Types referenced inside the rules by the '$' signs.
 * E.g.: if you reference a '$' in rule `type_identifier`
 * it will be a variable of type `SyntaxTreeNode`, as defined
 * in the SemanticVal union by the `asAstNode` field.
 */

%type <asAstNode> type_identifier builtin_type optional_return_type
%type <asAstNode> literal_const_expression identifier_expression
%type <asAstNode> expression array_expression array_subscript_expression object_constructor_expression
%type <asAstNode> translation_unit module_declaration statement statement_list optional_statement_list
%type <asAstNode> for_statement while_statement loop_statement break_statement continue_statement
%type <asAstNode> if_statement elseif_statement else_statement elseif_or_else_or_end
%type <asAstNode> enum_declaration enum_constant enum_constant_list
%type <asAstNode> struct_declaration struct_member_list
%type <asAstNode> func_call_expression func_declaration func_parameter_list_declaration parameter_list return_statement
%type <asAstNode> match_statement match_case match_case_list
%type <asAstNode> range_expression range_param range_or_array_or_ident_or_call
%type <asAstNode> let_var_declaration typed_var_declaration
%type <asAstNode> type_alias_declaration

/* +-------------------------------------------------+ *
 * | Yacc/Bison grammar rules:                       | *
 * +-------------------------------------------------+ */

/* ---- A couple defintions: ----

 * From the Bison manual:
   Each kind of syntactic unit or grouping is named by a 'symbol'. Those which are built by grouping
   smaller constructs according to grammatical rules are called nonterminal symbols; those which can't
   be subdivided are called terminal symbols or token types. We call a piece of input corresponding to
   a single terminal symbol a token, and a piece corresponding to a single nonterminal symbol a grouping.
   We can use the C language as an example of what symbols, terminal and nonterminal, mean.
   The tokens of C are identifiers, constants (numeric and string), and the various keywords,
   arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include
   `identifier`, `number`, `string`, plus one symbol for each keyword, operator or punctuation mark:
   `if`, `return`, `const`, `static`, `int`, `char`, `plus-sign`, `open-brace`, `close-brace`, etc...

 * A 'Shift' step advances in the input stream by one symbol.
   That shifted symbol becomes a new single-node parse tree.

 * A 'Reduce' step applies a completed grammar rule to some of the recent parse trees,
   joining them together as one tree with a new root symbol.

 * Statements:
   Statements do Something and are often composed of expressions (or other statements).
   Statements are everything that can make up a line. E.g.: if/while, return, function declaration, ...

 * Expressions:
   Expressions produce at least one value. Expressions only contain identifiers,
   literals and operators, where operators include arithmetic and boolean operators,
   the function call operator () the subscription operator [] and similar, and can
   be reduced to some kind of "value" or terminal symbol.

--------------------------------- */

%%

/*
 * NOTE: Rules that don't explicitly set $$ are
 * just returning the value of the first element.
 * i.e., it is the same as $$ = $1;
 */
translation_unit
    : statement_list { ctx.syntTree->setRoot(ctx.syntTree->newNode(AstNode::TranslationUnit, $1)); }
    ;

statement_list
    : statement_list statement { $$ = ctx.syntTree->newNode(AstNode::Statement, $1, $2); }
    | %empty                   { $$ = nullptr; }
    ;

statement
    : module_declaration
    | struct_declaration
    | enum_declaration
    | type_alias_declaration
    | func_declaration
    | let_var_declaration
    | if_statement
    | loop_statement
    | while_statement
    | for_statement
    | match_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression ";"
    ;

optional_statement_list
    : statement_list
    | optional_semicolon { $$ = nullptr; }
    ;

optional_semicolon
    : ";"
    | %empty
    ;

literal_const_expression
    : INT_LITERAL  { $$ = newLiteralNode(ctx, AstEval::Long,   $1); }
    | FLT_LITERAL  { $$ = newLiteralNode(ctx, AstEval::Float,  $1); }
    | BOOL_LITERAL { $$ = newLiteralNode(ctx, AstEval::Bool,   $1); }
    | STR_LITERAL  { $$ = newLiteralNode(ctx, AstEval::String, $1); }
    ;

builtin_type
    : TID_INT   { $$ = newTypeIdNode(ctx, AstEval::Int);     }
    | TID_LONG  { $$ = newTypeIdNode(ctx, AstEval::Long);    }
    | TID_FLT   { $$ = newTypeIdNode(ctx, AstEval::Float);   }
    | TID_BOOL  { $$ = newTypeIdNode(ctx, AstEval::Bool);    }
    | TID_STR   { $$ = newTypeIdNode(ctx, AstEval::String);  }
    | TID_ARRAY { $$ = newTypeIdNode(ctx, AstEval::Array);   }
    | TID_RANGE { $$ = newTypeIdNode(ctx, AstEval::Range);   }
    | TID_ANY   { $$ = newTypeIdNode(ctx, AstEval::Any);     }
    ;

type_identifier
    : builtin_type
    | IDENTIFIER { $$ = newTypeIdNode(ctx, AstEval::UDT, $1); }
    ;

identifier_expression
    : IDENTIFIER { $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprNameIdent, $1); }
    ;

module_declaration
    : "module" IDENTIFIER ";" { $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ModuleDefinition, $2); }
    ;

/*
 * Notes on the 'expression' rule:
 * Operator precedence is determined by the line ordering of the following declarations;
 * the higher the line number of the declaration (lower on the page), the higher the precedence.
 *
 * Operator precedence for Moon Lang follows the same precedences of C.
 * https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
 */
expression
    : identifier_expression
    | literal_const_expression
    | array_expression
    | range_expression
    | object_constructor_expression
    | expression[L] "%="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprModAssign,       $L, $R); }
    | expression[L] "/="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprDivAssign,       $L, $R); }
    | expression[L] "*="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprMulAssign,       $L, $R); }
    | expression[L] "-="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprSubAssign,       $L, $R); }
    | expression[L] "+="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprAddAssign,       $L, $R); }
    | expression[L] "="   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprAssign,          $L, $R); }
    | expression[L] "or"  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprLogicOr,         $L, $R); }
    | expression[L] "and" expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprLogicAnd,        $L, $R); }
    | expression[L] "!="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpNotEqual,     $L, $R); }
    | expression[L] "=="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpEqual,        $L, $R); }
    | expression[L] ">="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpGreaterEqual, $L, $R); }
    | expression[L] ">"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpGreaterThan,  $L, $R); }
    | expression[L] "<="  expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpLessEqual,    $L, $R); }
    | expression[L] "<"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprCmpLessThan,     $L, $R); }
    | expression[L] "-"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprSubtract,        $L, $R); }
    | expression[L] "+"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprAdd,             $L, $R); }
    | expression[L] "%"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprModulo,          $L, $R); }
    | expression[L] "/"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprDivide,          $L, $R); }
    | expression[L] "*"   expression[R] { $$ = ctx.syntTree->newNode(AstNode::ExprMultiply,        $L, $R); }
    | "not" expression[R]               { $$ = ctx.syntTree->newNode(AstNode::ExprLogicNot,            $R); }
    | "-"   expression[R]               { $$ = ctx.syntTree->newNode(AstNode::ExprUnaryMinus,          $R); }
    | "+"   expression[R]               { $$ = ctx.syntTree->newNode(AstNode::ExprUnaryPlus,           $R); }
    | array_subscript_expression
    | func_call_expression
    | "(" expression ")"
        {
            /* Wrapping an expr in ( ) gives it the highest precedence.
            Just reapply the rule with the new precedence. */
            $$ = $2;
        }
    ;

func_call_expression
    : IDENTIFIER "(" parameter_list ")"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprFuncCall, $1, $3);
        }
    ;

parameter_list
    : expression
    | expression "," parameter_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_declaration
    : "func" IDENTIFIER "(" func_parameter_list_declaration ")" optional_return_type optional_statement_list end_statement
        {
            /* child[0] = parameter list
             * child[1] = function body
             * child[2] = return type */
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::FuncDeclStatement, $2, $4, $7, $6, $6->getEval());
        }
    ;

func_parameter_list_declaration
    : typed_var_declaration
    | typed_var_declaration "," func_parameter_list_declaration
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | IDENTIFIER "..."
        {
            auto varArgsNode = newTypeIdNode(ctx, AstEval::VarArgs);
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement, $1,
                        varArgsNode, nullptr, nullptr, varArgsNode->getEval());
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

optional_return_type
    : "->" type_identifier
        {
            $$ = $2;
        }
    | %empty
        {
            $$ = newTypeIdNode(ctx, AstEval::Void);
        }
    ;

array_expression
    : "[" parameter_list "]"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNode(AstNode::ExprArrayLiteral, nullptr, $2, nullptr, AstEval::Array);
        }
    ;

array_subscript_expression
    : IDENTIFIER "[" expression "]"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprArraySubscript, $1, nullptr, $3, nullptr);
        }
    ;

object_constructor_expression
    : type_identifier "{" parameter_list "}"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprObjectConstructor, $1->getSymbol(),
                                                 nullptr, $1, $3, $1->getEval());
        }
    ;

/* NOTE: The type node will always be the second child (child[1]), if present */
typed_var_declaration
    : IDENTIFIER ":" type_identifier
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement,
                                  $1, nullptr, $3, nullptr, $3->getEval());
        }
    ;

/* NOTE: The type node will always be the second child (child[1]), if present */
let_var_declaration
    : "let" IDENTIFIER ":" type_identifier "=" expression ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement,
                                       $2, $6, $4, nullptr, $4->getEval());
        }
    | "let" IDENTIFIER ":" type_identifier ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement,
                                  $2, nullptr, $4, nullptr, $4->getEval());
        }
    | "let" IDENTIFIER "=" expression ";"
        {
            /* Eval Type unspecified; inferred from the expression */
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement,
                                  $2, $4, nullptr, nullptr, $4->getEval());
        }
    ;

if_statement
    : "if" expression "then" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::IfThenStatement, $2, $4);
        }
    | "if" expression "then" optional_statement_list else_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::IfThenElseStatement, $2, $4, $5);
        }
    | "if" expression "then" optional_statement_list elseif_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

elseif_statement
    : "elseif" expression "then" optional_statement_list elseif_or_else_or_end
        {
            $$ = ctx.syntTree->newNode(AstNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

else_statement
    : "else" optional_statement_list end_statement { $$ = $2; }
    ;

elseif_or_else_or_end
    : elseif_statement
    | else_statement
    | end_statement { $$ = nullptr; }
    ;

end_statement
    : "end" optional_semicolon
    ;

return_statement
    : "return" expression ";"
        {
            $$ = ctx.syntTree->newNode(AstNode::ReturnStatement, $2,
                                   nullptr, nullptr, $2->getEval());
        }
    ;

break_statement
    : "break" ";"
        {
            $$ = ctx.syntTree->newNode(AstNode::BreakStatement);
        }
    ;

continue_statement
    : "continue" ";"
        {
            $$ = ctx.syntTree->newNode(AstNode::ContinueStatement);
        }
    ;

loop_statement
    : "loop" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::LoopStatement, $2);
        }
    ;

while_statement
    : "while" expression "do" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::WhileStatement, $2, $4);
        }
    ;

for_statement
    : "for" IDENTIFIER "in" range_or_array_or_ident_or_call "do" optional_statement_list end_statement
        {
            /* loopVarNode type has to be inferred from the loop expression/range */
            auto loopVarNode = ctx.syntTree->newNodeWithSymbol(AstNode::VarDeclStatement, $2);
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ForStatement, nullptr, loopVarNode, $4, $6);
        }
    ;

match_statement
    : "match" IDENTIFIER "with" match_case_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::MatchStatement, $2, $4);
        }
    ;

match_case
    : "case" literal_const_expression "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::MatchCaseStatement, $2, $4);
        }
    | "case" range_or_array_or_ident_or_call "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::MatchCaseStatement, $2, $4);
        }
    | "default" "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(AstNode::MatchDefaultStatement, $3);
        }
    ;

match_case_list
    : match_case
    | match_case match_case_list
        {
            $$ = $1;
            $$->setChild(2, $2);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

range_or_array_or_ident_or_call
    : range_expression
    | array_expression
    | array_subscript_expression
    | func_call_expression
    | identifier_expression
    ;

range_expression
    : range_param ".." range_param
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNode(AstNode::ExprRange, nullptr, $1, $3, AstEval::Range);
        }
    ;

/*
 * Possible types for a range parameter:
 * variables/identifiers:         x .. y
 * function return val:           0 .. len()
 * integer literals:              0 .. 10
 * strings (OK for single char):  "a" .. "z"
 */
range_param
    : func_call_expression
    | identifier_expression
    | INT_LITERAL
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprLiteralConst, $1,
                     nullptr, nullptr, nullptr, moon::evalTypeFromSymbol(*$1));
        }
    | STR_LITERAL
        {
            auto symbol = $1;
            if (std::strlen(symbol->value.asStringPtr) != 1)
            {
                Parser::error("only character literals are allowed in range expressions.");
            }
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprLiteralConst, symbol,
                     nullptr, nullptr, nullptr, moon::evalTypeFromSymbol(*symbol));
        }
    ;

enum_declaration
    : "type" IDENTIFIER "enum" enum_constant_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::EnumDeclStatement, $2,
                                            $4, nullptr, nullptr, AstEval::UDT);
        }
    ;

enum_constant_list
    : enum_constant
    | enum_constant "," enum_constant_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

enum_constant
    : IDENTIFIER
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprNameIdent, $1,
                                  nullptr, nullptr, nullptr, AstEval::Long);
        }
    | IDENTIFIER "=" INT_LITERAL
        {
            auto enumValNode = ctx.syntTree->newNodeWithSymbol(AstNode::ExprLiteralConst, $3,
                                   nullptr, nullptr, nullptr, moon::evalTypeFromSymbol(*$3));

            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprNameIdent, $1,
                     nullptr, enumValNode, nullptr, enumValNode->getEval());
        }
    | IDENTIFIER "=" enum_constant
        {
            /* Second child is the name of a previously defined constant */
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->getEval());
        }
    ;

type_alias_declaration
    : "type" IDENTIFIER "=" type_identifier ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::TypeAliasDeclStatement, $2,
                                                 $4, nullptr, nullptr, AstEval::UDT);
        }
    ;

struct_declaration
    : "type" IDENTIFIER "struct" struct_member_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(AstNode::StructDeclStatement, $2,
                                              $4, nullptr, nullptr, AstEval::UDT);
        }
    ;

struct_member_list
    : typed_var_declaration
    | typed_var_declaration "," struct_member_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

%%

/* +-------------------------------------------------+ *
 * | Epilogue section, appended to output CPP file:  | *
 * +-------------------------------------------------+ */

namespace moon
{

int yylex(SemanticVal * yylval, ParseContext & ctx)
{
    ctx.yylval = yylval;
    return ctx.lexer->yylex();
}

void Parser::error(const std::string & message)
{
    MOON_ASSERT(ctx.lexer != nullptr);

    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    compilerError(message, filename, ctx.lexer->get_yylineno(), ctx.currText);
    throw ParserException{ "Parser error" };
}

} // namespace moon {}
