
/*
 * NOTE: Bison version 3.0 or higher recommended.
 * https://www.gnu.org/software/bison/manual/html_node/index.html
 */

/* +-------------------------------------------------+ *
 * | Bison configuration parameters:                 | *
 * +-------------------------------------------------+ */

%skeleton "lalr1.cc"
%defines

%define parse.assert true
%define parse.error  verbose

%define api.namespace     {moon}
%define parser_class_name {Parser}

%parse-param {ParseContext & ctx}
%lex-param   {ParseContext & ctx}

%{
/*
 * Nothing to be added in the prologue section at the moment.
 * Left it here because Vim's syntax highlighting gets messed
 * up if this section is missing.
 *
 * Most of the stuff depends on the header file, so they
 * must be placed inside the %code { } section.
 */
%}

/* +-------------------------------------------------+ *
 * | Additional verbatin code sections:              | *
 * +-------------------------------------------------+ */

/*
 * 'Requires' section is added to generated parser header file.
 * Good place for forward declaration and types used in the yylval union.
 */
%code requires
{

#define INC_PARSER 1
#include "common.hpp"
#undef  INC_PARSER

} /* %code requires */

/*
 * The unqualified code section is added to the implementation file, after
 * the parser header is included, which is the right place for these.
 */
%code
{

#include "symbol_table.hpp"
#include "syntax_tree.hpp"
#include "vm.hpp"

namespace moon
{

using STNode = SyntaxTreeNode::Type;
using STEval = SyntaxTreeNode::Eval;

[[noreturn]] static void parserError(ParseContext & ctx, const std::string & message) noexcept(false)
{
    MOON_ASSERT(ctx.lexer != nullptr);
    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    parserError(message, filename, ctx.lexer->lineno(), ctx.currText);
}

/*------------------------------------------------------------------*/
//FIXME temp; testing this new stuff...
//TODO remove the debug printfs!

struct VarInfo
{
    const SyntaxTreeNode::Eval stEval;
    const Variant::Type        varType;
    const TypeId * const       typeId;
};

// [var_symbol, var_info]
using VarInfoTable = HashTable<const Symbol *, VarInfo>;
static VarInfoTable * g_globalVars = new VarInfoTable{};
static VarInfoTable * g_localVars  = nullptr;

static const Symbol * g_currentFunction = nullptr;
static const Symbol * g_currentUDT = nullptr;

static bool isParsingFunction() noexcept { return g_currentFunction != nullptr; }
static bool isParsingUDT()      noexcept { return g_currentUDT != nullptr; }

static void requireGlobalScope(ParseContext & ctx, const char * elementName)
{
    if (isParsingFunction() || isParsingUDT())
    {
        parserError(ctx, toString(elementName) + " can only be declared at the global scope");
    }
}

static void beginFunc(ParseContext & ctx, const Symbol * funcNameSymbol)
{
    if (isParsingFunction())
    {
        parserError(ctx, "nested functions are currently unsupported");
    }
    if (isParsingUDT())
    {
        parserError(ctx, "member functions are currently unsupported");
    }

    g_localVars        = new VarInfoTable{};
    g_currentFunction  = funcNameSymbol;

    printf("BEGIN FUNC %s\n", g_currentFunction->name->chars);
}

static void endFunc(ParseContext & ctx)
{
    (void)ctx;
    printf("END FUNC %s\n", g_currentFunction->name->chars);

    g_localVars        = nullptr;
    g_currentFunction  = nullptr;
}

static void beginUDT(ParseContext & ctx, const Symbol * typeNameSymbol, const char * elementName)
{
    requireGlobalScope(ctx, elementName);
    g_currentUDT = typeNameSymbol;

    printf("BEGIN UDT %s\n", g_currentUDT->name->chars);
}

static void endUDT(ParseContext & ctx)
{
    (void)ctx;
    printf("END UDT %s\n", g_currentUDT->name->chars);

    g_currentUDT = nullptr;
}

/*------------------------------------------------------------------*/

static STEval varType2Eval(const Variant::Type varType)
{
    switch (varType)
    {
    case Variant::Type::Integer : return STEval::Long;
    case Variant::Type::Float   : return STEval::Double;
    case Variant::Type::Str     : return STEval::Str;
    case Variant::Type::Array   : return STEval::Array;
    case Variant::Type::Range   : return STEval::Range;
    case Variant::Type::Any     : return STEval::Any;
    case Variant::Type::Object  : return STEval::UDT;
    default : MOON_INTERNAL_EXCEPTION("can't convert Variant type '" + toString(varType) + "' to STEval!");
    } // switch (varType)
}

static Variant::Type eval2VarType(const STEval stEval)
{
    switch (stEval)
    {
    case STEval::Int    : return Variant::Type::Integer;
    case STEval::Long   : return Variant::Type::Integer;
    case STEval::Bool   : return Variant::Type::Integer;
    case STEval::Float  : return Variant::Type::Float;
    case STEval::Double : return Variant::Type::Float;
    case STEval::Str    : return Variant::Type::Str;
    case STEval::Array  : return Variant::Type::Array;
    case STEval::Range  : return Variant::Type::Range;
    case STEval::Any    : return Variant::Type::Any;
    case STEval::UDT    : return Variant::Type::Object;
    default : MOON_INTERNAL_EXCEPTION("can't convert STEval '" + toString(stEval) + "' to Variant type!");
    } // switch (stEval)
}

static const TypeId * eval2TypeId(const TypeTable & typeTable, const STEval stEval)
{
    switch (stEval)
    {
    case STEval::Int    : return typeTable.intTypeId;
    case STEval::Long   : return typeTable.longTypeId;
    case STEval::Bool   : return typeTable.boolTypeId;
    case STEval::Float  : return typeTable.floatTypeId;
    case STEval::Double : return typeTable.doubleTypeId;
    case STEval::Str    : return typeTable.strTypeId;
    case STEval::Array  : return typeTable.arrayTypeId;
    case STEval::Range  : return typeTable.rangeTypeId;
    case STEval::Any    : return typeTable.anyTypeId;
    case STEval::UDT    : return typeTable.objectTypeId;
    default : MOON_INTERNAL_EXCEPTION("can't convert STEval '" + toString(stEval) + "' to TypeId!");
    } // switch (stEval)
}

/*------------------------------------------------------------------*/

static void registerVariable(ParseContext & ctx,
                             const Symbol * nameSymbol,
                             const SyntaxTreeNode * initNode,
                             const SyntaxTreeNode * typeNode,
                             const STEval stEval, VarInfoTable & destTable)
{
    const SyntaxTreeNode * tidNode = nullptr;

    if (typeNode != nullptr)
    {
        tidNode = typeNode;
    }
    else if (initNode != nullptr)
    {
        tidNode = initNode;
    }
    else
    {
        parserError(ctx, "variable declaration requires an initializer");
    }

    const auto typeId = (stEval == STEval::UDT) ?
        ctx.vm->types.findTypeId(tidNode->symbol->name) :
        eval2TypeId(ctx.vm->types, stEval);

    if (typeId == nullptr)
    {
        std::string tname = color::white() + toString(tidNode->symbol->name) + color::restore();
        parserError(ctx, "cannot declare variable of undefined type '" + tname + "'");
    }

    destTable.insert(std::make_pair(nameSymbol, VarInfo{ stEval, eval2VarType(stEval), typeId }));

    printf("ADDING VAR: %s, %s, %s, %s\n", nameSymbol->name->chars, toString(stEval).c_str(),
           toString(typeId->name).c_str(), toString(eval2VarType(stEval)).c_str());
}

/*------------------------------------------------------------------*/

static STEval registerGlobalOrLocal(ParseContext & ctx, const Symbol * nameSymbol, SyntaxTreeNode * initNode,
                                    const SyntaxTreeNode * typeNode, STEval stEval)
{
    if (!isParsingFunction()) // Global scope or parsing a function declaration?
    {
        MOON_ASSERT(g_globalVars != nullptr);

        if (stEval == STEval::Undefined)
        {
            if (initNode == nullptr || initNode->symbol == nullptr)
            {
                parserError(ctx, "variable declaration requires an initializer");
            }

            // A global can be initialized from other globals
            const auto globIter = g_globalVars->find(initNode->symbol);
            if (globIter == g_globalVars->end())
            {
                std::string srcName = color::white() + toString(nameSymbol->name) + color::restore();
                std::string dstName = color::white() + toString(initNode->symbol->name) + color::restore();
                parserError(ctx, "initializing global variable '" + srcName + "' from unknown identifier '" + dstName + "'");
            }

            stEval = globIter->second.stEval;
            initNode->evalType = stEval;
        }

        if (g_globalVars->find(nameSymbol) != g_globalVars->end())
        {
            std::string vname = color::white() + toString(nameSymbol->name) + color::restore();
            parserError(ctx, "redefinition of global variable '" + vname + "'");
        }

        registerVariable(ctx, nameSymbol, initNode, typeNode, stEval, *g_globalVars);
    }
    else
    {
        MOON_ASSERT(g_globalVars != nullptr);
        MOON_ASSERT(g_localVars  != nullptr);

        if (stEval == STEval::Undefined)
        {
            if (initNode == nullptr || initNode->symbol == nullptr)
            {
                parserError(ctx, "variable declaration requires an initializer");
            }

            // A local can be initialized from other locals or globals
            const auto globIter = g_globalVars->find(initNode->symbol);
            if (globIter == g_globalVars->end())
            {
                // Try from a previous local variable
                const auto localIter = g_localVars->find(initNode->symbol);
                if (localIter == g_localVars->end())
                {
                    std::string srcName = color::white() + toString(nameSymbol->name) + color::restore();
                    std::string dstName = color::white() + toString(initNode->symbol->name) + color::restore();
                    parserError(ctx, "initializing local variable '" + srcName + "' from unknown identifier '" + dstName + "'");
                }
                stEval = localIter->second.stEval;
            }
            else
            {
                stEval = globIter->second.stEval;
            }
            initNode->evalType = stEval;
        }

        if (g_localVars->find(nameSymbol) != g_localVars->end())
        {
            std::string vname = color::white() + toString(nameSymbol->name) + color::restore();
            parserError(ctx, "redefinition of local variable '" + vname + "'");
        }

        registerVariable(ctx, nameSymbol, initNode, typeNode, stEval, *g_localVars);
    }

    return stEval;
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newVarDeclNode(ParseContext & ctx, const Symbol * nameSymbol, SyntaxTreeNode * initNode,
                                       const SyntaxTreeNode * typeNode, STEval stEval)
{
    // Member vars get collected somewhere else.
    if (!isParsingUDT())
    {
        stEval = registerGlobalOrLocal(ctx, nameSymbol, initNode, typeNode, stEval);
    }
    return ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                           nameSymbol, initNode, typeNode,
                                           nullptr, stEval);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newLiteralNode(ParseContext & ctx, const STEval stEval, const Symbol * symbol)
{
    return ctx.syntTree->newNodeWithEval(STNode::ExprLiteralConst, symbol, stEval);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newTypeIdNode(ParseContext & ctx, const STEval stEval,
                                      const Symbol * symbol = nullptr)
{
    if (symbol == nullptr)
    {
        symbol = symbolFromEval(*ctx.symTable, stEval);
    }
    return ctx.syntTree->newNodeWithEval(STNode::ExprTypeIdent, symbol, stEval);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newCompareNode(ParseContext & ctx, const STNode type,
                                       const SyntaxTreeNode * child0,
                                       const SyntaxTreeNode * child1,
                                       const SyntaxTreeNode * child2)
{
    // Special 'if X then' case:
    if (child0->nodeType == STNode::ExprNameIdent)
    {
        // Turn it into a compare against zero/null/false expression:
        auto zeroNode = newLiteralNode(ctx, STEval::Long, ctx.symTable->findOrDefineValue(0));
        auto compNode = ctx.syntTree->newNode(STNode::ExprCmpNotEqual, child0, zeroNode);
        return ctx.syntTree->newNode(type, compNode, child1, child2);
    }
    // Normal 'if X comp Y then' case:
    return ctx.syntTree->newNode(type, child0, child1, child2);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newBinaryOpNode(ParseContext & ctx, const STNode type,
                                        const SyntaxTreeNode * lhs,
                                        const SyntaxTreeNode * rhs)
{
    //if (!compatibleTypes(lhs, rhs)
    //{
    // *** TODO ERROR, cannot perform operation 'XYZ' on typeA and typeB ***
    //}
    return ctx.syntTree->newNode(type, lhs, rhs, nullptr, rhs->evalType);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newUnaryOpNode(ParseContext & ctx, const STNode type, const SyntaxTreeNode * operand)
{
    return ctx.syntTree->newNode(type, operand, nullptr, nullptr, operand->evalType);
}

/*------------------------------------------------------------------*/

static void collectFunctionArgTypes(const SyntaxTreeNode * root, Variant::Type * argTypesOut,
                                    UInt32 & argCountOut, UInt32 & extraFlagsOut)
{
    if (root == nullptr)
    {
        return;
    }

    auto argNode = root->getChild(1);
    auto stEval  = argNode->evalType;

    if (stEval == STEval::VarArgs)
    {
        extraFlagsOut |= Function::VarArgs;
        return;
    }

    argTypesOut[argCountOut++] = eval2VarType(stEval);
    collectFunctionArgTypes(root->getChild(0), argTypesOut, argCountOut, extraFlagsOut);
}

/*------------------------------------------------------------------*/

static void collectObjMembers(ParseContext & ctx, const SyntaxTreeNode * root, Object * objOut)
{
    if (root == nullptr)
    {
        return;
    }

    const auto stEval  = root->evalType;
    const auto varName = root->symbol->name;

    if (objOut->hasMember(varName))
    {
        std::string mname = color::white() + toString(varName) + color::restore();
        parserError(ctx, objOut->getTypeName() + " member '" + mname + "' was defined more than once");
    }

    Variant data{ eval2VarType(stEval) };

    // Members that reference other User Defined Types require special handling.
    if (data.type == Variant::Type::Object)
    {
        MOON_ASSERT(root->getChild(1) != nullptr);

        const auto typeName = root->getChildSymbol(1)->name;
        const TypeId * typeId = ctx.vm->types.findTypeId(typeName);

        if (typeId == nullptr)
        {
            std::string tname = color::white() + toString(typeName) + color::restore();
            parserError(ctx, "cannot declare member variable of undefined type '" + tname + "'");
        }

        data.value.asObject = const_cast<Object *>(typeId->templateObject);
    }

    printf("ADDING OBJ MEMBER: %s: %s\n", toString(varName).c_str(), toString(data.type).c_str());
    objOut->addMember(varName, data);
    collectObjMembers(ctx, root->getChild(0), objOut);
}

/*------------------------------------------------------------------*/

static void initEnumMembers(ParseContext & ctx, const SyntaxTreeNode * root, Object * objOut, Int64 & nextEnumIntVal)
{
    if (root == nullptr)
    {
        return;
    }

    const auto stEval  = root->evalType;
    const auto varName = root->symbol->name;

    if (objOut->hasMember(varName))
    {
        std::string mname = color::white() + toString(varName) + color::restore();
        parserError(ctx, objOut->getTypeName() + " member '" + mname + "' was defined more than once");
    }

    Variant data{ eval2VarType(stEval) };
    const auto initExprNode = root->getChild(1);

    if (initExprNode != nullptr)
    {
        if (initExprNode->nodeType == STNode::ExprLiteralConst)
        {
            if (initExprNode->evalType == STEval::Int ||
                initExprNode->evalType == STEval::Long)
            {
                MOON_ASSERT(data.type == Variant::Type::Integer);
                data = variantFromSymbol(*ctx.vm, *initExprNode->symbol);
            }
            else // string, float, bool
            {
                const auto initVal = variantFromSymbol(*ctx.vm, *initExprNode->symbol);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
                // Enum strings have program lifetime.
                if (data.type == Variant::Type::Str)
                {
                    data.getAsString()->flags.isPersistent = true;
                }
            }
        }
        else // identifier / other enum member ref
        {
            if (initExprNode->nodeType == STNode::ExprNameIdent)
            {
                const auto initVal = objOut->findMemberVar(initExprNode->symbol->name);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
            }
            else
            {
                MOON_ASSERT(initExprNode->nodeType == STNode::ExprMemberRef);

                // Already checked when parsing, so an assert suffices.
                const auto otherEnum = ctx.vm->types.findTypeId(initExprNode->getChildSymbol(0)->name);
                MOON_ASSERT(otherEnum != nullptr);

                const auto initVal = otherEnum->templateObject->findMemberVar(initExprNode->getChildSymbol(1)->name);
                MOON_ASSERT(data.type == initVal.type);
                data = initVal;
            }
        }
    }
    else // sequential integer list
    {
        MOON_ASSERT(data.type == Variant::Type::Integer);
        data.value.asInteger = nextEnumIntVal++;
    }

    if (data.type == Variant::Type::Integer)
    {
        nextEnumIntVal = data.value.asInteger + 1;
    }

    printf("ADDING ENUM CONST: %s: %s\n", toString(varName).c_str(), toString(data.type).c_str());
    objOut->addMember(varName, data);
    initEnumMembers(ctx, root->getChild(0), objOut, nextEnumIntVal);
}

/*------------------------------------------------------------------*/

static STEval enumMemberConstantReference(ParseContext & ctx, SyntaxTreeNode * eTypeNode, SyntaxTreeNode * eConstNode)
{
    MOON_ASSERT(eTypeNode->symbol  != nullptr);
    MOON_ASSERT(eConstNode->symbol != nullptr);

    const auto typeName = eTypeNode->symbol->name;
    const auto enumType = ctx.vm->types.findTypeId(typeName);

    if (enumType == nullptr)
    {
        std::string ename = color::white() + toString(typeName) + color::restore();
        parserError(ctx, "reference to undefined enum type '" + ename + "'");
    }
    MOON_ASSERT(enumType->templateObject != nullptr);

    const auto constName = eConstNode->symbol->name;
    const auto enumConst = enumType->templateObject->findMemberIndex(constName);

    if (enumConst < 0)
    {
        std::string cname = color::white() + toString(typeName) + "." + toString(constName) + color::restore();
        parserError(ctx, "reference to undefined enum constant '" + cname + "'");
    }

    // Okay
    const STEval stEvalConst = varType2Eval(enumType->templateObject->getMemberAt(enumConst).data.type);
    eTypeNode->evalType  = STEval::UDT;
    eConstNode->evalType = stEvalConst;
    return stEvalConst;
}

/*------------------------------------------------------------------*/

static void checkEnumInitializers(ParseContext & ctx, const SyntaxTreeNode * root,
                                  const SyntaxTreeNode * iterNode, int & numOfNonIntegralConstants)
{
    if (iterNode == nullptr)
    {
        return;
    }

    if (iterNode->evalType == STEval::Undefined)
    {
        // Trying to init the constant with itself?
        if (iterNode->symbol == iterNode->getChildSymbol(1))
        {
            std::string cname = color::white() + toString(iterNode->symbol->name) + color::restore();
            parserError(ctx, "assigning enum constant '" + cname + "' to itself");
        }

        // Reference to a previously defined constant in this enum?
        bool foundIt = false;
        for (auto node = root; node != iterNode; node = node->getChild(0))
        {
            if (node->symbol == iterNode->getChildSymbol(1))
            {
                const_cast<SyntaxTreeNode *>(iterNode)->evalType = node->evalType;
                const_cast<SyntaxTreeNode *>(iterNode->getChild(1))->evalType = node->evalType;
                foundIt = true;
                break;
            }
        }

        if (!foundIt)
        {
            std::string cname = color::white() + toString(iterNode->getChildSymbol(1)->name) + color::restore();
            parserError(ctx, "assigning undefined identifier '" + cname + "' to enum constant");
        }
    }

    // If not explicitly initialized, we assume sequential integer constants.
    // But in that case, previous constants must also be integers.
    if (iterNode->getChild(1) == nullptr)
    {
        if (numOfNonIntegralConstants != 0)
        {
            parserError(ctx, "unable to deduce next constant value for enum with non-integer constants");
        }
    }

    if (iterNode->evalType != STEval::Int &&
        iterNode->evalType != STEval::Long)
    {
        ++numOfNonIntegralConstants;
    }

    checkEnumInitializers(ctx, root, iterNode->getChild(0), numOfNonIntegralConstants);
}

/*------------------------------------------------------------------*/

int yylex(SemanticVal * yylval, ParseContext & ctx)
{
    ctx.yylval = yylval;
    return ctx.lexer->yylex();
}

void Parser::error(const std::string & message)
{
    parserError(ctx, message);
}

} /* namespace moon */
} /* %code */

/* +-------------------------------------------------+ *
 * | Tokens read by the Lexer (terminal symbols):    | *
 * +-------------------------------------------------+ */

/*
 * In the rules below, we can either use the token id
 * (e.g. OP_ASSIGN) or its string alias (e.g. "=").
 * The string alias is also used to print the token
 * on error messages generated by Bison.
 */

/* Operators: arithmetical/assigment/unary */
%token OP_ASSIGN                  "="
%token OP_PLUS                    "+"
%token OP_MINUS                   "-"
%token OP_MULTIPLY                "*"
%token OP_DIVIDE                  "/"
%token OP_MODULO                  "%"
%token OP_PLUS_ASSIGN             "+="
%token OP_MINUS_ASSIGN            "-="
%token OP_MULTIPLY_ASSIGN         "*="
%token OP_DIVIDE_ASSIGN           "/="
%token OP_MODULO_ASSIGN           "%="

/* Operators: comparisson */
%token OP_CMP_GREATER_THAN        ">"
%token OP_CMP_LESS_THAN           "<"
%token OP_CMP_GREATER_EQUAL       ">="
%token OP_CMP_LESS_EQUAL          "<="
%token OP_CMP_EQUAL               "=="
%token OP_CMP_NOT_EQUAL           "!="

/* Operators: logical/boolean */
%token OP_LOGIC_AND               "and"
%token OP_LOGIC_OR                "or"
%token OP_LOGIC_NOT               "not"

/* Built-in type ids: */
%token TID_INT                    "int"
%token TID_LONG                   "long"
%token TID_FLT                    "float"
%token TID_DBL                    "double"
%token TID_BOOL                   "bool"
%token TID_STR                    "str"
%token TID_ARRAY                  "array"
%token TID_RANGE                  "range"
%token TID_ANY                    "any"

/* Language keywords: */
%token KW_IF                      "if"
%token KW_THEN                    "then"
%token KW_ELSE                    "else"
%token KW_ELSEIF                  "elseif"
%token KW_END                     "end"
%token KW_RETURN                  "return"
%token KW_LET                     "let"
%token KW_FUNC                    "func"
%token KW_MATCH                   "match"
%token KW_WITH                    "with"
%token KW_CASE                    "case"
%token KW_DEFAULT                 "default"
%token KW_IN                      "in"
%token KW_DO                      "do"
%token KW_FOR                     "for"
%token KW_WHILE                   "while"
%token KW_LOOP                    "loop"
%token KW_BREAK                   "break"
%token KW_CONTINUE                "continue"
%token KW_TYPE                    "type"
%token KW_ENUM                    "enum"
%token KW_STRUCT                  "struct"

/* Literal constants: */
%token <asSymbol> INT_LITERAL     "literal integer constant"
%token <asSymbol> FLT_LITERAL     "literal floating-point constant"
%token <asSymbol> BOOL_LITERAL    "literal boolean constant"
%token <asSymbol> STR_LITERAL     "literal string constant"

/* Miscellaneous: */
%token            MEMBER_REF      "."
%token            OPEN_PAR        "("
%token            CLOSE_PAR       ")"
%token            OPEN_CBRAC      "{"
%token            CLOSE_CBRAC     "}"
%token            OPEN_BRAC       "["
%token            CLOSE_BRAC      "]"
%token            COMMA           ","
%token            SEMICOLON       ";"
%token            COLON           ":"
%token            RANGE           ".."
%token            VARARGS         "..."
%token            ARROW           "->"
%token <asSymbol> IDENTIFIER      "identifier"
%token            END_OF_FILE  0  "end of file"

/* +-------------------------------------------------+ *
 * | Operator associativity & rule semantic types:   | *
 * +-------------------------------------------------+ */

/*
 * Operator associativity: LEFT or RIGHT.
 * NOTES:
 * - Using associativity equivalent to the C language.
 * - Order of this list matters! Lower on page, higher precedence.
 * - These should match the order in the 'expression' rule below.
 */
%right OP_MODULO_ASSIGN
%right OP_DIVIDE_ASSIGN
%right OP_MULTIPLY_ASSIGN
%right OP_MINUS_ASSIGN
%right OP_PLUS_ASSIGN
%right OP_ASSIGN
%left  OP_LOGIC_OR
%left  OP_LOGIC_AND
%left  OP_CMP_NOT_EQUAL
%left  OP_CMP_EQUAL
%left  OP_CMP_GREATER_EQUAL
%left  OP_CMP_GREATER_THAN
%left  OP_CMP_LESS_EQUAL
%left  OP_CMP_LESS_THAN
%left  OP_MINUS
%left  OP_PLUS
%left  OP_MODULO
%left  OP_DIVIDE
%left  OP_MULTIPLY
%right OP_LOGIC_NOT

/* Context depended fix for unary +,-. See:
 * https://www.gnu.org/software/bison/manual/html_node/Contextual-Precedence.html */
%right UNARY_MINUS
%right UNARY_PLUS

/* Member dereference with the dot operator */
%left  MEMBER_REF

/*
 * Types referenced inside the rules by the '$' signs.
 * E.g.: if you reference a '$' in rule 'type_identifier'
 * it will be a variable of type 'SyntaxTreeNode', as defined
 * in the SemanticVal/YYSTYPE union by the 'asSTNode' field.
 */
%type <asSTNode> type_identifier builtin_type optional_return_type
%type <asSTNode> literal_const_expression identifier_expression
%type <asSTNode> expression array_expression array_subscript_expression object_constructor_expression
%type <asSTNode> translation_unit statement optional_statement_list
%type <asSTNode> for_statement while_statement loop_statement break_statement continue_statement
%type <asSTNode> if_statement elseif_statement else_statement elseif_or_else_or_end
%type <asSTNode> enum_declaration enum_constant enum_constant_list
%type <asSTNode> struct_declaration struct_member_list
%type <asSTNode> func_call_expression func_declaration func_parameter_list_declaration parameter_list return_statement
%type <asSTNode> match_statement match_case match_default match_case_list match_param match_case_param
%type <asSTNode> range_expression range_param range_or_array_or_ident_or_call
%type <asSTNode> let_var_declaration typed_var_declaration
%type <asSTNode> type_alias_declaration

/*
 * Rule the parser starts from. If not explicitly stated,
 * it uses the first nonterminal rule in the below grammar.
 */
%start translation_unit

/* +-------------------------------------------------+ *
 * | Yacc/Bison grammar rules:                       | *
 * +-------------------------------------------------+ */

/* ---- A couple definitions: ----

 * From the Bison manual:
   Each kind of syntactic unit or grouping is named by a 'symbol'. Those which are built by grouping
   smaller constructs according to grammatical rules are called nonterminal symbols; those which can't
   be subdivided are called terminal symbols or token types. We call a piece of input corresponding to
   a single terminal symbol a token, and a piece corresponding to a single nonterminal symbol a grouping.
   We can use the C language as an example of what symbols, terminal and nonterminal, mean.
   The tokens of C are identifiers, constants (numeric and string), and the various keywords,
   arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include
   `identifier`, `number`, `string`, plus one symbol for each keyword, operator or punctuation mark:
   `if`, `return`, `const`, `static`, `int`, `char`, `plus-sign`, `open-brace`, `close-brace`, etc...

 * A 'Shift' step advances in the input stream by one symbol.
   That shifted symbol becomes a new single-node parse tree.

 * A 'Reduce' step applies a completed grammar rule to some of the recent parse trees,
   joining them together as one tree with a new root symbol.

 * Statements:
   Statements do Something and are often composed of expressions (or other statements).
   Statements are everything that can make up a line. E.g.: if/while, return, function declaration, ...

 * Expressions:
   Expressions produce at least one value. Expressions only contain identifiers,
   literals and operators, where operators include arithmetic and boolean operators,
   the function call operator () the subscription operator [] and similar, and can
   be reduced to some kind of "value" or terminal symbol.

--------------------------------- */

%%

/*
 * NOTE: Rules that don't explicitly set $$ are
 * just returning the value of the first element.
 * i.e., it is the same as $$ = $1;
 */

/*---------------------------------------------------.
| Miscellaneous statements, literals, built-in types |
`---------------------------------------------------*/

/* Starting rule */
translation_unit
    : optional_statement_list
        {
            auto treeRoot = ctx.syntTree->newNode(STNode::TranslationUnit, $1, nullptr, nullptr, STEval::Void);
            ctx.syntTree->setRoot(treeRoot);
        }
    ;

/* Zero or more statements allowed */
optional_statement_list
    : optional_statement_list statement
        {
            $$ = ctx.syntTree->newNode(STNode::Statement, $1, $2, nullptr, STEval::Void);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

statement
    : struct_declaration
    | enum_declaration
    | type_alias_declaration
    | func_declaration
    | let_var_declaration
    | if_statement
    | loop_statement
    | while_statement
    | for_statement
    | match_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression ";"
    ;

optional_semicolon
    : ";"
    | %empty
    ;

end_statement
    : "end" optional_semicolon
    ;

literal_const_expression
    : INT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Long,   $1); }
    | FLT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Double, $1); }
    | BOOL_LITERAL { $$ = newLiteralNode(ctx, STEval::Bool,   $1); }
    | STR_LITERAL  { $$ = newLiteralNode(ctx, STEval::Str,    $1); }
    ;

builtin_type
    : TID_INT   { $$ = newTypeIdNode(ctx, STEval::Int);    }
    | TID_LONG  { $$ = newTypeIdNode(ctx, STEval::Long);   }
    | TID_FLT   { $$ = newTypeIdNode(ctx, STEval::Float);  }
    | TID_DBL   { $$ = newTypeIdNode(ctx, STEval::Double); }
    | TID_BOOL  { $$ = newTypeIdNode(ctx, STEval::Bool);   }
    | TID_STR   { $$ = newTypeIdNode(ctx, STEval::Str);    }
    | TID_ARRAY { $$ = newTypeIdNode(ctx, STEval::Array);  }
    | TID_RANGE { $$ = newTypeIdNode(ctx, STEval::Range);  }
    | TID_ANY   { $$ = newTypeIdNode(ctx, STEval::Any);    }
    ;

type_identifier
    : builtin_type
    | IDENTIFIER { $$ = newTypeIdNode(ctx, STEval::UDT, $1); }
    ;

identifier_expression
    : IDENTIFIER { $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1); }
    ;

/*------------------------.
| First-class expressions |
`------------------------*/

/*
 * Notes on the 'expression' rule:
 * Operator precedence is determined by the line ordering of the following declarations;
 * the higher the line number of the declaration (lower on the page), higher the precedence.
 *
 * Operator precedence for Moon Lang follows the same precedences of C.
 * https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
 */
expression
    : identifier_expression
    | literal_const_expression
    | array_expression
    | range_expression
    | object_constructor_expression
    | expression[L] "%="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModAssign,       $L, $R); }
    | expression[L] "/="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivAssign,       $L, $R); }
    | expression[L] "*="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMulAssign,       $L, $R); }
    | expression[L] "-="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubAssign,       $L, $R); }
    | expression[L] "+="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAddAssign,       $L, $R); }
    | expression[L] "="   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAssign,          $L, $R); }
    | expression[L] "or"  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicOr,         $L, $R); }
    | expression[L] "and" expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicAnd,        $L, $R); }
    | expression[L] "!="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpNotEqual,     $L, $R); }
    | expression[L] "=="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpEqual,        $L, $R); }
    | expression[L] ">="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterEqual, $L, $R); }
    | expression[L] ">"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterThan,  $L, $R); }
    | expression[L] "<="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessEqual,    $L, $R); }
    | expression[L] "<"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessThan,     $L, $R); }
    | expression[L] "-"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubtract,        $L, $R); }
    | expression[L] "+"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAdd,             $L, $R); }
    | expression[L] "%"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModulo,          $L, $R); }
    | expression[L] "/"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivide,          $L, $R); }
    | expression[L] "*"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMultiply,        $L, $R); }
    | "not" expression[R] { $$ = newUnaryOpNode(ctx, STNode::ExprLogicNot, $R); }
    | "-" expression[R] %prec UNARY_MINUS { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryMinus, $R); }
    | "+" expression[R] %prec UNARY_PLUS  { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryPlus, $R);  }
    | expression[L] "." expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMemberRef, $L, $R); }
    | array_subscript_expression
    | func_call_expression
    | "(" expression ")"
        {
            // Wrapping an expr in ( ) gives it the highest precedence.
            // Just reapply the rule with the new precedence.
            $$ = $2;
        }
    ;

/*------------------------------.
| Parameter lists and functions |
`------------------------------*/

/* Shared by constructors, function calls and array literals */
parameter_list
    : expression
    | expression "," parameter_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_parameter_list_declaration
    : typed_var_declaration
    | typed_var_declaration "," func_parameter_list_declaration
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | IDENTIFIER "..."
        {
            // Note: In a VarArgs function, the varargs node will be at child 1.
            // This is to facilitate the traversal in collectFunctionArgTypes().
            auto varArgsNode = newTypeIdNode(ctx, STEval::VarArgs);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $1,
                        nullptr, varArgsNode, nullptr, varArgsNode->evalType);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_call_expression
    : IDENTIFIER "(" parameter_list ")"
        {
            // Second child is the parameter_list chain.
            // First is reserved for chaining the call itself to another parameter_list
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprFuncCall, $1, nullptr, $3);
        }
    ;

func_declaration
    : "func" IDENTIFIER { beginFunc(ctx, $2); } "(" func_parameter_list_declaration ")" optional_return_type optional_statement_list end_statement
        {
            // child[0] = parameter list
            // child[1] = function body
            // child[2] = return type
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::FuncDeclStatement, $2, $5, $8, $7, $7->evalType);

            // Redefinition not allowed. We also don't currently support function overloads.
            auto funcName = $2->name;
            if (ctx.vm->functions.findFunction(funcName))
            {
                std::string fname = color::white() + toString(funcName) + color::restore();
                parserError(ctx, "function '" + fname + "' was defined more than once");
            }

            UInt32 extraFlags = 0;
            UInt32 argCount   = 0;
            Variant::Type argTypes[Function::MaxArguments];

            // nullptr indicates no return type (void).
            const Variant::Type * pRetType = nullptr;
            Variant::Type retTypeTemp;

            if ($7->evalType != STEval::Void)
            {
                retTypeTemp = eval2VarType($7->evalType);
                pRetType = &retTypeTemp;
            }

            collectFunctionArgTypes($5, argTypes, argCount, extraFlags);
            if (extraFlags & Function::VarArgs)
            {
                argCount = 0;
            }

            // Register the new function:
            ctx.vm->functions.addFunction(funcName, pRetType, (argCount != 0) ? argTypes : nullptr,
                                          argCount, 0, extraFlags, nullptr);
            endFunc(ctx);
        }
    ;

/* A function declaration can either have an explicit return type or implicit void return */
optional_return_type
    : "->" type_identifier
        {
            $$ = $2;
        }
    | %empty
        {
            $$ = newTypeIdNode(ctx, STEval::Void);
        }
    ;

/*-----------------------------------.
| Array literals and array subscript |
`-----------------------------------*/

array_expression
    : "[" parameter_list "]"
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNode(STNode::ExprArrayLiteral, nullptr, $2, nullptr, STEval::Array);
        }
    ;

array_subscript_expression
    : identifier_expression "[" expression "]"
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, $1, $3);
        }
    | func_call_expression "[" expression "]"
        {
            // Only makes sense when the function returns an array type
            $$ = ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, $1, $3);
        }
    ;

/*------------------------.
| Object constructor call |
`------------------------*/

object_constructor_expression
    : type_identifier "{" parameter_list "}"
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprObjectConstructor, $1->symbol,
                                                           nullptr, $3, $1, $1->evalType);
        }
    ;

/*-----------------.
| Var declarations |
`-----------------*/

/* NOTE: The type node will always be the second child (child[1]), if present */
typed_var_declaration
    : IDENTIFIER ":" type_identifier
        {
            $$ = newVarDeclNode(ctx, $1, nullptr, $3, $3->evalType);
        }
    ;

/* NOTE: The type node will always be the second child (child[1]), if present */
let_var_declaration
    : "let" IDENTIFIER ":" type_identifier "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $6, $4, $4->evalType);
        }
    | "let" IDENTIFIER ":" type_identifier ";"
        {
            $$ = newVarDeclNode(ctx, $2, nullptr, $4, $4->evalType);
        }
    | "let" IDENTIFIER "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $4, nullptr, $4->evalType);
        }
    ;

/*----------------------------.
| If, else, elseif statements |
`----------------------------*/

if_statement
    : "if" expression "then" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenStatement, $2, $4, nullptr);
        }
    | "if" expression "then" optional_statement_list else_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseStatement, $2, $4, $5);
        }
    | "if" expression "then" optional_statement_list elseif_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

elseif_statement
    : "elseif" expression "then" optional_statement_list elseif_or_else_or_end
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

else_statement
    : "else" optional_statement_list end_statement { $$ = $2; }
    ;

elseif_or_else_or_end
    : elseif_statement
    | else_statement
    | end_statement { $$ = nullptr; }
    ;

/*--------------------------.
| Loops and jump statements |
`--------------------------*/

return_statement
    : "return" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ReturnStatement);
        }
    | "return" expression ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ReturnStatement, $2, nullptr, nullptr, $2->evalType);
        }
    ;

break_statement
    : "break" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::BreakStatement);
        }
    ;

continue_statement
    : "continue" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ContinueStatement);
        }
    ;

loop_statement
    : "loop" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::LoopStatement, $2);
        }
    ;

while_statement
    : "while" expression "do" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::WhileStatement, $2, $4, nullptr);
        }
    ;

for_statement
    : "for" IDENTIFIER "in" range_or_array_or_ident_or_call "do" optional_statement_list end_statement
        {
            // loopVarNode type has to be inferred from the loop expression/range
            auto loopVarNode = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $2);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ForStatement, nullptr, loopVarNode, $4, $6);
        }
    ;

/*-----------------------.
| Match switch statement |
`-----------------------*/

/* Things allowed on a 'match X with' statement: */
match_param
    : literal_const_expression
    | identifier_expression
    | array_subscript_expression
    | func_call_expression
    ;

/* Things that can appear as the argument of a 'case' statement: */
match_case_param
    : literal_const_expression
    | range_or_array_or_ident_or_call
    ;

match_statement
    : "match" match_param "with" match_case_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchStatement, $2, $4);
        }
    ;

match_default
    : "default" "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchDefaultStatement, nullptr, $3);
        }
    ;

match_case
    : "case" match_case_param "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchCaseStatement, $2, $4);
        }
    ;

match_case_list
    : match_case match_case_list
        {
            $$ = $1;
            $$->setChild(2, $2);
        }
    | match_default
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*------------------.
| Range expressions |
`------------------*/

range_or_array_or_ident_or_call
    : range_expression
    | array_expression
    | array_subscript_expression
    | func_call_expression
    | identifier_expression
    ;

range_expression
    : range_param ".." range_param
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNode(STNode::ExprRange, nullptr, $1, $3, STEval::Range);
        }
    ;

/*
 * Possible elements for a range parameter:
 * variables/identifiers:         x .. y
 * function return val:           0 .. len()
 * integer literals:              0 .. 10
 * strings (OK for single char):  "a" .. "z"
 */
range_param
    : func_call_expression
    | identifier_expression
    | INT_LITERAL
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, $1,
                          nullptr, nullptr, nullptr, evalTypeFromSymbol(*$1));
        }
    | STR_LITERAL
        {
            const auto symbol = $1;
            if (symbol->value.asString->length != 1)
            {
                parserError(ctx, "only single character literals are allowed in range expressions");
            }
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, symbol,
                          nullptr, nullptr, nullptr, evalTypeFromSymbol(*symbol));
        }
    ;

/*-----------------.
| Enum declaration |
`-----------------*/

enum_declaration
    : "type" IDENTIFIER "enum" { beginUDT(ctx, $2, "enum"); } enum_constant_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::EnumDeclStatement, $2,
                                            $5, nullptr, nullptr, STEval::UDT);

            // Redefinition not allowed.
            const auto typeName = $2->name;
            if (ctx.vm->types.findTypeId(typeName))
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "enum '" + tname + "' was defined more than once");
            }

            Object * templateObj = Enum::newInstance(*ctx.vm, nullptr);
            auto newTypeId = ctx.vm->types.addTypeId(typeName, &Enum::newInstance, templateObj, false);
            templateObj->setTypeId(newTypeId);
            templateObj->markTypeTemplate();

            // This will search for undefined STEvals in the initializers and update
            // them if the enum const references a global constant or a previously
            // defined sibling constant in this enum. It also checks that uninitialized
            // constant are not used on an enum with non-integral values.
            int numOfNonIntegralConstants = 0;
            checkEnumInitializers(ctx, $5, $5, numOfNonIntegralConstants);

            Int64 nextEnumIntVal = 0;
            initEnumMembers(ctx, $5, templateObj, nextEnumIntVal);
            endUDT(ctx);
        }
    ;

enum_constant
    : IDENTIFIER
        { // Uninitialized enum constant
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                  nullptr, nullptr, nullptr, STEval::Long);
        }
    | IDENTIFIER "=" literal_const_expression
        { // Constant initialized from compile-time literal value
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression
        { // Constant with explicit initializer (a prev constant from this enum)
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression "." identifier_expression
        { // Constant initialized from a reference to a member constant of another enum
            const auto stEval = enumMemberConstantReference(ctx, $3, $5);
            auto initExpr = newBinaryOpNode(ctx, STNode::ExprMemberRef, $3, $5);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, initExpr, nullptr, stEval);
        }
    ;

enum_constant_list
    : enum_constant
    | enum_constant "," enum_constant_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*--------------------------------.
| Structured types and type alias |
`--------------------------------*/

type_alias_declaration
    : "type" IDENTIFIER "=" type_identifier { requireGlobalScope(ctx, "type alias"); } ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::TypeAliasDeclStatement, $2,
                                                 $4, nullptr, nullptr, STEval::UDT);

            const auto aliasName = $2->name;
            const auto typeName  = $4->symbol->name;

            // Redefinition not allowed.
            if (ctx.vm->types.findTypeId(aliasName))
            {
                std::string tname = color::white() + toString(aliasName) + color::restore();
                parserError(ctx, "type alias '" + tname + "' was defined more than once");
            }

            // New definition:
            const auto existingType = ctx.vm->types.findTypeId(typeName);
            if (existingType == nullptr)
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "trying to alias undefined type '" + tname + "'");
            }

            ctx.vm->types.addTypeAlias(existingType, aliasName);
        }
    ;

struct_declaration
    : "type" IDENTIFIER "struct" { beginUDT(ctx, $2, "struct"); } struct_member_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::StructDeclStatement, $2,
                                              $5, nullptr, nullptr, STEval::UDT);

            // Redefinition not allowed.
            const auto typeName = $2->name;
            if (ctx.vm->types.findTypeId(typeName))
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                parserError(ctx, "struct '" + tname + "' was defined more than once");
            }

            Object * templateObj = Struct::newInstance(*ctx.vm, nullptr);
            auto newTypeId = ctx.vm->types.addTypeId(typeName, &Struct::newInstance, templateObj, false);
            templateObj->setTypeId(newTypeId);
            templateObj->markTypeTemplate();

            collectObjMembers(ctx, $5, templateObj);
            endUDT(ctx);
        }
    ;

struct_member_list
    : typed_var_declaration
    | typed_var_declaration "," struct_member_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

%%
