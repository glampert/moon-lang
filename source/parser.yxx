
/*
 * NOTE: Bison version 3.0 or higher recommended.
 * https://www.gnu.org/software/bison/manual/html_node/index.html
 */

/* +-------------------------------------------------+ *
 * | Bison configuration parameters:                 | *
 * +-------------------------------------------------+ */

%skeleton "lalr1.cc"
%defines

%define parse.assert true
%define parse.error  verbose

%define api.namespace     {moon}
%define parser_class_name {Parser}

%parse-param {ParseContext & ctx}
%lex-param   {ParseContext & ctx}

%{
/*
 * Nothing to be added in the prologue section at the moment.
 * Left it here because Vim's syntax highlighting gets messed
 * up if this section is missing.
 *
 * Most of the stuff depends on the header file, so they
 * must be placed inside the %code { } section.
 */
%}

/* +-------------------------------------------------+ *
 * | Additional verbatin code sections:              | *
 * +-------------------------------------------------+ */

/* 'Requires' section is added to generated parser header file.
 * Good place for forward declaration and types used in the yylval union. */
%code requires
{

#define INC_PARSER 1
#include "common.hpp"
#undef  INC_PARSER

} /* %code requires */

/* The unqualified code section is added to the implementation file, after
 * the parser header is included, which is the right place for these. */
%code
{

#include "symbol_table.hpp"
#include "syntax_tree.hpp"
#include "runtime.hpp"

namespace moon
{

using STNode = SyntaxTreeNode::Type;
using STEval = SyntaxTreeNode::Eval;

/*------------------------------------------------------------------*/

static Variant::Type eval2VarType(const STEval evalType)
{
    switch (evalType)
    {
    case STEval::Int    : return Variant::Type::Integer;
    case STEval::Long   : return Variant::Type::Integer;
    case STEval::Bool   : return Variant::Type::Integer;
    case STEval::Float  : return Variant::Type::Float;
    case STEval::String : return Variant::Type::String;
    case STEval::UDT    : return Variant::Type::Object;
    default : internalError("can't covert STEval to Variant::Type", __FILE__, __LINE__);
    } // switch (evalType)
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newLiteralNode(ParseContext & ctx,
                                       const STEval tid,
                                       const Symbol * symbol)
{
    return ctx.syntTree->newNodeWithEval(STNode::ExprLiteralConst, symbol, tid);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newTypeIdNode(ParseContext & ctx,
                                      const STEval tid,
                                      const Symbol * symbol = nullptr)
{
    if (symbol == nullptr)
    {
        symbol = symbolFromEval(*ctx.symTable, tid);
    }
    return ctx.syntTree->newNodeWithEval(STNode::ExprTypeIdent, symbol, tid);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newCompareNode(ParseContext & ctx, const STNode type,
                                       const SyntaxTreeNode * child0,
                                       const SyntaxTreeNode * child1,
                                       const SyntaxTreeNode * child2)
{
    // Special 'if X then' case:
    if (child0->nodeType == STNode::ExprNameIdent)
    {
        // Turn it into a compare against zero/null/false expression:
        auto zeroNode = newLiteralNode(ctx, STEval::Long, ctx.symTable->findOrDefineValue(0));
        auto compNode = ctx.syntTree->newNode(STNode::ExprCmpNotEqual, child0, zeroNode);
        return ctx.syntTree->newNode(type, compNode, child1, child2);
    }
    // Normal 'if X comp Y then' case:
    return ctx.syntTree->newNode(type, child0, child1, child2);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newBinaryOpNode(ParseContext & ctx, const STNode type,
                                        const SyntaxTreeNode * lhs,
                                        const SyntaxTreeNode * rhs)
{
    //if (!compatibleTypes(lhs, rhs)
    //{
    // *** TODO ERROR, cannot perform operation 'XYZ' on typeA and typeB ***
    //}
    return ctx.syntTree->newNode(type, lhs, rhs, nullptr, rhs->evalType);
}

/*------------------------------------------------------------------*/

static SyntaxTreeNode * newUnaryOpNode(ParseContext & ctx, const STNode type,
                                       const SyntaxTreeNode * operand)
{
    return ctx.syntTree->newNode(type, operand, nullptr, nullptr, operand->evalType);
}

/*------------------------------------------------------------------*/

static void collectFunctionArgTypes(const SyntaxTreeNode * root,
                                    Variant::Type * argTypesOut,
                                    UInt32 & argCountOut,
                                    UInt32 & extraFlagsOut)
{
    if (root == nullptr)
    {
        return;
    }

    auto argNode  = root->getChild(1);
    auto evalType = argNode->evalType;

    if (evalType == STEval::VarArgs)
    {
        extraFlagsOut |= Function::VarArgs;
        return;
    }

    argTypesOut[argCountOut++] = eval2VarType(evalType);
    collectFunctionArgTypes(root->getChild(0), argTypesOut, argCountOut, extraFlagsOut);
}

/*------------------------------------------------------------------*/

static void collectObjMembers(ParseContext & ctx, const SyntaxTreeNode * root, Object * objOut)
{
    if (root == nullptr)
    {
        return;
    }

    auto evalType = root->evalType;
    auto varName  = root->symbol->name;

    if (objOut->hasMember(varName))
    {
        std::string mname = color::white() + toString(varName) + color::restore();
        ctx.parser->error("object member '" + mname + "' was defined more than once");
    }

    Variant data{ eval2VarType(evalType) };

    // Members that reference other User Defined Types require special handling.
    if (data.type == Variant::Type::Object)
    {
        MOON_ASSERT(root->getChild(1) != nullptr);
        auto typeName = root->getChildSymbol(1)->name;

        Object * templateObj;
        const TypeId * tid = ctx.typeTable->findTypeId(typeName);

        if (tid == nullptr)
        {
            templateObj = Struct::createInstance(nullptr, ctx.objList);
            tid = ctx.typeTable->addTypeId(typeName, &Struct::createInstance, templateObj, false);
            templateObj->typeId = tid;
        }
        else
        {
            templateObj = const_cast<Object *>(tid->templateObject);
        }

        data.value.asObject = templateObj;
    }

    objOut->addMember(varName, data);
    collectObjMembers(ctx, root->getChild(0), objOut);
}

} /* namespace moon */
} /* %code */

/* +-------------------------------------------------+ *
 * | Tokens read by the Lexer (terminal symbols):    | *
 * +-------------------------------------------------+ */

/*
 * In the rules below, we can either use the token id
 * (e.g. OP_ASSIGN) or its string alias (e.g. "=").
 * The string alias is also used to print the token
 * on error messages generated by Bison.
 */

/* Operators: arithmetical/assigment/unary */
%token OP_ASSIGN                  "="
%token OP_PLUS                    "+"
%token OP_MINUS                   "-"
%token OP_MULTIPLY                "*"
%token OP_DIVIDE                  "/"
%token OP_MODULO                  "%"
%token OP_PLUS_EQUAL              "+="
%token OP_MINUS_EQUAL             "-="
%token OP_MULTIPLY_EQUAL          "*="
%token OP_DIVIDE_EQUAL            "/="
%token OP_MODULO_EQUAL            "%="

/* Operators: comparisson */
%token OP_CMP_GREATER_THAN        ">"
%token OP_CMP_LESS_THAN           "<"
%token OP_CMP_GREATER_EQUAL       ">="
%token OP_CMP_LESS_EQUAL          "<="
%token OP_CMP_EQUAL               "=="
%token OP_CMP_NOT_EQUAL           "!="

/* Operators: logical/boolean */
%token OP_LOGIC_AND               "and"
%token OP_LOGIC_OR                "or"
%token OP_LOGIC_NOT               "not"

/* Built-in type ids: */
%token TID_INT                    "int"
%token TID_LONG                   "long"
%token TID_FLT                    "float"
%token TID_BOOL                   "bool"
%token TID_STR                    "str"
%token TID_ARRAY                  "array"
%token TID_RANGE                  "range"
%token TID_ANY                    "any"

/* Language keywords: */
%token KW_IF                      "if"
%token KW_THEN                    "then"
%token KW_ELSE                    "else"
%token KW_ELSEIF                  "elseif"
%token KW_END                     "end"
%token KW_RETURN                  "return"
%token KW_LET                     "let"
%token KW_FUNC                    "func"
%token KW_MATCH                   "match"
%token KW_WITH                    "with"
%token KW_CASE                    "case"
%token KW_DEFAULT                 "default"
%token KW_IN                      "in"
%token KW_DO                      "do"
%token KW_FOR                     "for"
%token KW_WHILE                   "while"
%token KW_LOOP                    "loop"
%token KW_BREAK                   "break"
%token KW_CONTINUE                "continue"
%token KW_TYPE                    "type"
%token KW_ENUM                    "enum"
%token KW_STRUCT                  "struct"
%token KW_MODULE                  "module"

/* Literal constants: */
%token <asSymbol> INT_LITERAL     "literal integer constant"
%token <asSymbol> FLT_LITERAL     "literal floating-point constant"
%token <asSymbol> BOOL_LITERAL    "literal boolean constant"
%token <asSymbol> STR_LITERAL     "literal string constant"

/* Miscellaneous: */
%token            MEMBER_REF      "."
%token            OPEN_PAR        "("
%token            CLOSE_PAR       ")"
%token            OPEN_CBRAC      "{"
%token            CLOSE_CBRAC     "}"
%token            OPEN_BRAC       "["
%token            CLOSE_BRAC      "]"
%token            COMMA           ","
%token            SEMICOLON       ";"
%token            COLON           ":"
%token            RANGE           ".."
%token            VARARGS         "..."
%token            ARROW           "->"
%token <asSymbol> IDENTIFIER      "identifier"
%token            END_OF_FILE  0  "end of file"

/* +-------------------------------------------------+ *
 * | Operator associativity & rule semantic types:   | *
 * +-------------------------------------------------+ */

/*
 * Operator associativity: LEFT or RIGHT.
 * NOTE: Using associativity equivalent to the C language.
 */

%right OP_MODULO_EQUAL
%right OP_DIVIDE_EQUAL
%right OP_MULTIPLY_EQUAL
%right OP_MINUS_EQUAL
%right OP_PLUS_EQUAL
%right OP_ASSIGN
%right OP_LOGIC_NOT
%left  OP_LOGIC_OR
%left  OP_LOGIC_AND
%left  OP_CMP_NOT_EQUAL
%left  OP_CMP_EQUAL
%left  OP_CMP_GREATER_EQUAL
%left  OP_CMP_GREATER_THAN
%left  OP_CMP_LESS_EQUAL
%left  OP_CMP_LESS_THAN
%left  OP_MINUS
%left  OP_PLUS
%left  OP_MODULO
%left  OP_DIVIDE
%left  OP_MULTIPLY
%left  MEMBER_REF

/*
 * Types referenced inside the rules by the '$' signs.
 * E.g.: if you reference a '$' in rule `type_identifier`
 * it will be a variable of type `SyntaxTreeNode`, as defined
 * in the SemanticVal union by the `asSTNode` field.
 */

%type <asSTNode> type_identifier builtin_type optional_return_type
%type <asSTNode> literal_const_expression identifier_expression
%type <asSTNode> expression array_expression array_subscript_expression object_constructor_expression
%type <asSTNode> translation_unit module_declaration statement statement_list optional_statement_list
%type <asSTNode> for_statement while_statement loop_statement break_statement continue_statement
%type <asSTNode> if_statement elseif_statement else_statement elseif_or_else_or_end
%type <asSTNode> enum_declaration enum_constant enum_constant_list
%type <asSTNode> struct_declaration struct_member_list
%type <asSTNode> func_call_expression func_declaration func_parameter_list_declaration parameter_list return_statement
%type <asSTNode> match_statement match_case match_case_list match_param
%type <asSTNode> range_expression range_param range_or_array_or_ident_or_call
%type <asSTNode> let_var_declaration typed_var_declaration
%type <asSTNode> type_alias_declaration

/* +-------------------------------------------------+ *
 * | Yacc/Bison grammar rules:                       | *
 * +-------------------------------------------------+ */

/* ---- A couple defintions: ----

 * From the Bison manual:
   Each kind of syntactic unit or grouping is named by a 'symbol'. Those which are built by grouping
   smaller constructs according to grammatical rules are called nonterminal symbols; those which can't
   be subdivided are called terminal symbols or token types. We call a piece of input corresponding to
   a single terminal symbol a token, and a piece corresponding to a single nonterminal symbol a grouping.
   We can use the C language as an example of what symbols, terminal and nonterminal, mean.
   The tokens of C are identifiers, constants (numeric and string), and the various keywords,
   arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include
   `identifier`, `number`, `string`, plus one symbol for each keyword, operator or punctuation mark:
   `if`, `return`, `const`, `static`, `int`, `char`, `plus-sign`, `open-brace`, `close-brace`, etc...

 * A 'Shift' step advances in the input stream by one symbol.
   That shifted symbol becomes a new single-node parse tree.

 * A 'Reduce' step applies a completed grammar rule to some of the recent parse trees,
   joining them together as one tree with a new root symbol.

 * Statements:
   Statements do Something and are often composed of expressions (or other statements).
   Statements are everything that can make up a line. E.g.: if/while, return, function declaration, ...

 * Expressions:
   Expressions produce at least one value. Expressions only contain identifiers,
   literals and operators, where operators include arithmetic and boolean operators,
   the function call operator () the subscription operator [] and similar, and can
   be reduced to some kind of "value" or terminal symbol.

--------------------------------- */

%%

/*
 * NOTE: Rules that don't explicitly set $$ are
 * just returning the value of the first element.
 * i.e., it is the same as $$ = $1;
 */

/*---------------------------------------------------.
| Miscellaneous statements, literals, built-in types |
`---------------------------------------------------*/

translation_unit
    : statement_list { ctx.syntTree->setRoot(ctx.syntTree->newNode(STNode::TranslationUnit, $1)); }
    ;

statement_list
    : statement_list statement { $$ = ctx.syntTree->newNode(STNode::Statement, $1, $2); }
    | %empty                   { $$ = nullptr; }
    ;

statement
    : module_declaration
    | struct_declaration
    | enum_declaration
    | type_alias_declaration
    | func_declaration
    | let_var_declaration
    | if_statement
    | loop_statement
    | while_statement
    | for_statement
    | match_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression ";"
    ;

optional_statement_list
    : statement_list
    | optional_semicolon { $$ = nullptr; }
    ;

optional_semicolon
    : ";"
    | %empty
    ;

end_statement
    : "end" optional_semicolon
    ;

literal_const_expression
    : INT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Long,   $1); }
    | FLT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Float,  $1); }
    | BOOL_LITERAL { $$ = newLiteralNode(ctx, STEval::Bool,   $1); }
    | STR_LITERAL  { $$ = newLiteralNode(ctx, STEval::String, $1); }
    ;

builtin_type
    : TID_INT   { $$ = newTypeIdNode(ctx, STEval::Int);    }
    | TID_LONG  { $$ = newTypeIdNode(ctx, STEval::Long);   }
    | TID_FLT   { $$ = newTypeIdNode(ctx, STEval::Float);  }
    | TID_BOOL  { $$ = newTypeIdNode(ctx, STEval::Bool);   }
    | TID_STR   { $$ = newTypeIdNode(ctx, STEval::String); }
    | TID_ARRAY { $$ = newTypeIdNode(ctx, STEval::Array);  }
    | TID_RANGE { $$ = newTypeIdNode(ctx, STEval::Range);  }
    | TID_ANY   { $$ = newTypeIdNode(ctx, STEval::Any);    }
    ;

type_identifier
    : builtin_type
    | IDENTIFIER { $$ = newTypeIdNode(ctx, STEval::UDT, $1); }
    ;

identifier_expression
    : IDENTIFIER { $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1); }
    ;

module_declaration
    : "module" IDENTIFIER ";" { $$ = ctx.syntTree->newNodeWithSymbol(STNode::ModuleDefinition, $2); }
    ;

/*------------------------.
| First-class expressions |
`------------------------*/

/*
 * Notes on the 'expression' rule:
 * Operator precedence is determined by the line ordering of the following declarations;
 * the higher the line number of the declaration (lower on the page), higher the precedence.
 *
 * Operator precedence for Moon Lang follows the same precedences of C.
 * https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
 */
expression
    : identifier_expression
    | literal_const_expression
    | array_expression
    | range_expression
    | object_constructor_expression
    | expression[L] "%="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModAssign,       $L, $R); }
    | expression[L] "/="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivAssign,       $L, $R); }
    | expression[L] "*="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMulAssign,       $L, $R); }
    | expression[L] "-="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubAssign,       $L, $R); }
    | expression[L] "+="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAddAssign,       $L, $R); }
    | expression[L] "="   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAssign,          $L, $R); }
    | expression[L] "or"  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicOr,         $L, $R); }
    | expression[L] "and" expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicAnd,        $L, $R); }
    | expression[L] "!="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpNotEqual,     $L, $R); }
    | expression[L] "=="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpEqual,        $L, $R); }
    | expression[L] ">="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterEqual, $L, $R); }
    | expression[L] ">"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterThan,  $L, $R); }
    | expression[L] "<="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessEqual,    $L, $R); }
    | expression[L] "<"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessThan,     $L, $R); }
    | expression[L] "-"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubtract,        $L, $R); }
    | expression[L] "+"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAdd,             $L, $R); }
    | expression[L] "%"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModulo,          $L, $R); }
    | expression[L] "/"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivide,          $L, $R); }
    | expression[L] "*"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMultiply,        $L, $R); }
    |               "not" expression[R] { $$ = newUnaryOpNode(ctx,  STNode::ExprLogicNot,            $R); }
    |               "-"   expression[R] { $$ = newUnaryOpNode(ctx,  STNode::ExprUnaryMinus,          $R); }
    |               "+"   expression[R] { $$ = newUnaryOpNode(ctx,  STNode::ExprUnaryPlus,           $R); }
    | expression[L] "."   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMemberRef,       $L, $R); }
    | array_subscript_expression
    | func_call_expression
    | "(" expression ")"
        {
            /* Wrapping an expr in ( ) gives it the highest precedence.
            Just reapply the rule with the new precedence. */
            $$ = $2;
        }
    ;

/*------------------------------.
| Parameter lists and functions |
`------------------------------*/

/* Shared by constructors, function calls and array literals */
parameter_list
    : expression
    | expression "," parameter_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_parameter_list_declaration
    : typed_var_declaration
    | typed_var_declaration "," func_parameter_list_declaration
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | IDENTIFIER "..."
        {
            // Note: In a VarArgs function, the varargs node will be at child 1.
            // This is to facilitate the traversal in collectFunctionArgTypes().
            auto varArgsNode = newTypeIdNode(ctx, STEval::VarArgs);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $1,
                        nullptr, varArgsNode, nullptr, varArgsNode->evalType);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_call_expression
    : IDENTIFIER "(" parameter_list ")"
        {
            /* Second child is the parameter_list chain.
               First is reserved for chaining the call itself to another parameter_list */
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprFuncCall, $1, nullptr, $3);
        }
    ;

func_declaration
    : "func" IDENTIFIER "(" func_parameter_list_declaration ")" optional_return_type optional_statement_list end_statement
        {
            /* child[0] = parameter list
             * child[1] = function body
             * child[2] = return type */
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::FuncDeclStatement, $2, $4, $7, $6, $6->evalType);

            // Redefinition not allowed. We also don't currently support function overloads.
            auto funcName = $2->name;
            if (ctx.fnTable->findFunction(funcName))
            {
                std::string fname = color::white() + toString(funcName) + color::restore();
                Parser::error("function '" + fname + "' was defined more than once");
            }

            UInt32 extraFlags = 0;
            UInt32 argCount   = 0;
            Variant::Type argTypes[Function::MaxArguments];

            // nullptr indicates no return type (void).
            const Variant::Type * pRetType = nullptr;
            Variant::Type retTypeTemp;

            if ($6->evalType != STEval::Void)
            {
                retTypeTemp = eval2VarType($6->evalType);
                pRetType = &retTypeTemp;
            }

            collectFunctionArgTypes($4, argTypes, argCount, extraFlags);
            if (extraFlags & Function::VarArgs)
            {
                argCount = 0;
            }

            // Register the new function:
            ctx.fnTable->addFunction(funcName, pRetType, (argCount != 0) ? argTypes : nullptr,
                                     argCount, 0, extraFlags, nullptr);
        }
    ;

/* A function declaration can either have an explicit return type or implicit void return */
optional_return_type
    : "->" type_identifier
        {
            $$ = $2;
        }
    | %empty
        {
            $$ = newTypeIdNode(ctx, STEval::Void);
        }
    ;

/*-----------------------------------.
| Array literals and array subscript |
`-----------------------------------*/

array_expression
    : "[" parameter_list "]"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNode(STNode::ExprArrayLiteral, nullptr, $2, nullptr, STEval::Array);
        }
    ;

array_subscript_expression
    : identifier_expression "[" expression "]"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, $1, $3);
        }
    | func_call_expression "[" expression "]"
        {
            /* Only makes sense when the function returns an array type */
            $$ = ctx.syntTree->newNode(STNode::ExprArraySubscript, nullptr, $1, $3);
        }
    ;

/*------------------------.
| Object constructor call |
`------------------------*/

object_constructor_expression
    : type_identifier "{" parameter_list "}"
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprObjectConstructor, $1->symbol,
                                                           nullptr, $3, $1, $1->evalType);
        }
    ;

/*-----------------.
| Var declarations |
`-----------------*/

/* NOTE: The type node will always be the second child (child[1]), if present */
typed_var_declaration
    : IDENTIFIER ":" type_identifier
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                  $1, nullptr, $3, nullptr, $3->evalType);
        }
    ;

/* NOTE: The type node will always be the second child (child[1]), if present */
let_var_declaration
    : "let" IDENTIFIER ":" type_identifier "=" expression ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                       $2, $6, $4, nullptr, $4->evalType);
        }
    | "let" IDENTIFIER ":" type_identifier ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                  $2, nullptr, $4, nullptr, $4->evalType);
        }
    | "let" IDENTIFIER "=" expression ";"
        {
            /* Eval Type unspecified; inferred from the expression */
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement,
                                  $2, $4, nullptr, nullptr, $4->evalType);
        }
    ;

/*----------------------------.
| If, else, elseif statements |
`----------------------------*/

if_statement
    : "if" expression "then" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenStatement, $2, $4, nullptr);
        }
    | "if" expression "then" optional_statement_list else_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseStatement, $2, $4, $5);
        }
    | "if" expression "then" optional_statement_list elseif_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

elseif_statement
    : "elseif" expression "then" optional_statement_list elseif_or_else_or_end
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

else_statement
    : "else" optional_statement_list end_statement { $$ = $2; }
    ;

elseif_or_else_or_end
    : elseif_statement
    | else_statement
    | end_statement { $$ = nullptr; }
    ;

/*-------------------------.
| Loops and sub-statements |
`-------------------------*/

return_statement
    : "return" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ReturnStatement);
        }
    | "return" expression ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ReturnStatement, $2,
                                   nullptr, nullptr, $2->evalType);
        }
    ;

break_statement
    : "break" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::BreakStatement);
        }
    ;

continue_statement
    : "continue" ";"
        {
            $$ = ctx.syntTree->newNode(STNode::ContinueStatement);
        }
    ;

loop_statement
    : "loop" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::LoopStatement, $2);
        }
    ;

while_statement
    : "while" expression "do" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::WhileStatement, $2, $4, nullptr);
        }
    ;

for_statement
    : "for" IDENTIFIER "in" range_or_array_or_ident_or_call "do" optional_statement_list end_statement
        {
            /* loopVarNode type has to be inferred from the loop expression/range */
            auto loopVarNode = ctx.syntTree->newNodeWithSymbol(STNode::VarDeclStatement, $2);
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ForStatement, nullptr, loopVarNode, $4, $6);
        }
    ;

/*-----------------------.
| Match switch statement |
`-----------------------*/

/* Things we allow on a 'match X with' statement: */
match_param
    : literal_const_expression
    | identifier_expression
    | array_subscript_expression
    | func_call_expression
    ;

match_statement
    : "match" match_param "with" match_case_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchStatement, $2, $4);
        }
    ;

match_case
    : "case" literal_const_expression "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchCaseStatement, $2, $4);
        }
    | "case" range_or_array_or_ident_or_call "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchCaseStatement, $2, $4);
        }
    | "default" "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchDefaultStatement, nullptr, $3);
        }
    ;

match_case_list
    : match_case
    | match_case match_case_list
        {
            $$ = $1;
            $$->setChild(2, $2);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*------------------.
| Range expressions |
`------------------*/

range_or_array_or_ident_or_call
    : range_expression
    | array_expression
    | array_subscript_expression
    | func_call_expression
    | identifier_expression
    ;

range_expression
    : range_param ".." range_param
        {
            /* First child reserved for parameter_list chains */
            $$ = ctx.syntTree->newNode(STNode::ExprRange, nullptr, $1, $3, STEval::Range);
        }
    ;

/*
 * Possible types for a range parameter:
 * variables/identifiers:         x .. y
 * function return val:           0 .. len()
 * integer literals:              0 .. 10
 * strings (OK for single char):  "a" .. "z"
 */
range_param
    : func_call_expression
    | identifier_expression
    | INT_LITERAL
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, $1,
                          nullptr, nullptr, nullptr, evalTypeFromSymbol(*$1));
        }
    | STR_LITERAL
        {
            auto symbol = $1;
            if (symbol->value.asString->length != 1)
            {
                Parser::error("only character literals are allowed in range expressions");
            }
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, symbol,
                          nullptr, nullptr, nullptr, evalTypeFromSymbol(*symbol));
        }
    ;

/*-----------------.
| Enum declaration |
`-----------------*/

enum_declaration
    : "type" IDENTIFIER "enum" enum_constant_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::EnumDeclStatement, $2,
                                            $4, nullptr, nullptr, STEval::UDT);
        }
    ;

enum_constant_list
    : enum_constant
    | enum_constant "," enum_constant_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

enum_constant
    : IDENTIFIER
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                  nullptr, nullptr, nullptr, STEval::Long);
        }
    | IDENTIFIER "=" INT_LITERAL
        {
            /*FIXME should allow other types of literal constants actually, not just int ...*/
            auto enumValNode = ctx.syntTree->newNodeWithSymbol(STNode::ExprLiteralConst, $3,
                                        nullptr, nullptr, nullptr, evalTypeFromSymbol(*$3));

            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                     nullptr, enumValNode, nullptr, enumValNode->evalType);
        }
    | IDENTIFIER "=" enum_constant
        {
            /* Second child is the name of a previously defined constant */
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::ExprNameIdent, $1,
                                       nullptr, $3, nullptr, $3->evalType);
        }
    ;

/*--------------------------------.
| Structured types and type alias |
`--------------------------------*/

type_alias_declaration
    : "type" IDENTIFIER "=" type_identifier ";"
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::TypeAliasDeclStatement, $2,
                                                 $4, nullptr, nullptr, STEval::UDT);

            auto aliasName = $2->name;
            auto typeName  = $4->symbol->name;

            // Redefinition not allowed.
            if (ctx.typeTable->findTypeId(aliasName))
            {
                std::string tname = color::white() + toString(aliasName) + color::restore();
                Parser::error("type alias '" + tname + "' was defined more than once");
            }

            // New definition:
            auto existingType = ctx.typeTable->findTypeId(typeName);
            if (existingType == nullptr)
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                Parser::error("trying to alias undefined type '" + tname + "'");
            }

            ctx.typeTable->addTypeAlias(existingType, aliasName);
        }
    ;

struct_declaration
    : "type" IDENTIFIER "struct" struct_member_list end_statement
        {
            $$ = ctx.syntTree->newNodeWithSymbol(STNode::StructDeclStatement, $2,
                                              $4, nullptr, nullptr, STEval::UDT);

            // Redefinition not allowed.
            auto typeName = $2->name;
            if (ctx.typeTable->findTypeId(typeName))
            {
                std::string tname = color::white() + toString(typeName) + color::restore();
                Parser::error("struct '" + tname + "' was defined more than once");
            }

            Object * templateObj = Struct::createInstance(nullptr, ctx.objList);
            auto newTypeId = ctx.typeTable->addTypeId(typeName, &Struct::createInstance, templateObj, false);

            templateObj->typeId = newTypeId;
            collectObjMembers(ctx, $4, templateObj);
        }
    ;

struct_member_list
    : typed_var_declaration
    | typed_var_declaration "," struct_member_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

%%

/* +-------------------------------------------------+ *
 * | Epilogue section, appended to output CPP file:  | *
 * +-------------------------------------------------+ */

namespace moon
{

int yylex(SemanticVal * yylval, ParseContext & ctx)
{
    ctx.yylval = yylval;
    return ctx.lexer->yylex();
}

void Parser::error(const std::string & message)
{
    MOON_ASSERT(ctx.lexer != nullptr);
    const std::string filename = (ctx.srcFile != nullptr) ? *ctx.srcFile : "???";
    parserError(message, filename, ctx.lexer->lineno(), ctx.currText);
}

} /* namespace moon */
